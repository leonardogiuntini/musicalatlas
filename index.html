<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Musical Atlas</title>

  <style>
    :root { color-scheme: light; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Header centered */
    header {
      padding: 14px 16px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    header strong { font-size: 20px; }

    /* Everything (except RTF content) centered */
    .top {
      padding: 12px 16px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    /* Search bar line */
    .searchLine {
      width: min(820px, 100%);
      display: flex;
      justify-content: center;
    }
    .searchWrap {
      width: 100%;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }
    input[type="search"] {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    input[type="search"]:focus { border-color: #222; }

    /* Results (horizontal) */
    .resultsLine {
      width: min(980px, 100%);
      display: none;
      overflow-x: auto;
      gap: 8px;
      padding-bottom: 4px;
      scroll-behavior: smooth;
      justify-content: flex-start;
    }
    .resultsLine::-webkit-scrollbar { height: 8px; }
    .resultsLine::-webkit-scrollbar-thumb { background: #ddd; border-radius: 999px; }

    /* Line: Menu button + Path (centered, scrollable if needed, auto-scrolled to end) */
    .menuPathLine {
      width: min(980px, 100%);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: nowrap;
    }

    .pathScroller {
      display: flex;
      gap: 8px;
      align-items: center;
      overflow-x: auto;
      scroll-behavior: smooth;
      padding-bottom: 4px;
      max-width: calc(100% - 90px);
      justify-content: flex-start;
    }
    .pathScroller::-webkit-scrollbar { height: 8px; }
    .pathScroller::-webkit-scrollbar-thumb { background: #ddd; border-radius: 999px; }

    /* Line: Choices (centered, wraps) */
    .choicesLine {
      width: min(980px, 100%);
      display: none;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    /* Back/Forward line */
    .navLine {
      width: min(980px, 100%);
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      min-height: 42px;
    }

    /* Button sizing: adapts to text */
    .btn, .chip, .choice, .navBtn, .resultBtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: auto;
      white-space: nowrap;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      font-size: 14px;
      line-height: 1;
    }

    /* Menu button: white inactive, black active */
    .btn {
      border: 1px solid #222;
      background: transparent;
      color: #222;
      padding: 10px 12px;
    }
    .btn.active {
      background: #222;
      color: #fff;
    }

    /* Path chips: always black */
    .chip {
      border: 1px solid #222;
      background: #222;
      color: #fff;
      padding: 7px 10px;
      font-size: 12px;
    }

    /* Selectable choices/results: white */
    .choice, .resultBtn, .navBtn {
      border: 1px solid #ddd;
      background: #fff;
      color: #222;
      padding: 10px 12px;
    }
    .choice:hover, .resultBtn:hover, .navBtn:hover { border-color: #aaa; }

    /* Nav buttons < > */
    .navBtn {
      width: 42px;
      height: 42px;
      padding: 0;
      font-size: 18px;
    }

    /* Document area (content itself NOT centered by the top UI rules) */
    .docWrap {
      padding: 18px 16px 48px;
    }

    .docFrame {
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,.06);
      background: #fff;
      max-width: 1000px;
      margin: 0 auto;
    }

    /* Readability max width */
    .docContent {
      max-width: 72ch;
      margin: 0 auto;
      font-size: 18px;
      line-height: 1.65;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .docContent a { color: inherit; text-decoration: underline; }

    /* Welcome (offline setup) */
    .welcome {
      display: none;
      width: min(920px, 100%);
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,.06);
      background: #fff;
      margin: 14px auto 0;
    }
    .notice {
      border-left: 4px solid #222;
      padding: 10px 12px;
      background:#f7f7f7;
      border-radius: 10px;
      margin: 10px 0;
      font-size: 13px;
      color: #444;
    }
    .muted { color:#555; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    /* Small helper row inside welcome */
    .welcomeActions { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }

    /* Hide elements */
    .hidden { display: none !important; }
  </style>

  <!-- rtf.js bundles -->
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/WMFJS.bundle.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/EMFJS.bundle.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/RTFJS.bundle.js"></script>
</head>

<body>
  <header>
    <strong>Musical Atlas</strong>
  </header>

  <div class="top">
    <!-- Search bar centered, ABOVE menu button -->
    <div class="searchLine">
      <div class="searchWrap">
        <input id="searchInput" type="search" placeholder="Search inside pages…" autocomplete="off" />
      </div>
    </div>

    <!-- Search results -->
    <div id="resultsLine" class="resultsLine"></div>

    <!-- Menu + Path -->
    <div class="menuPathLine">
      <button id="menuBtn" class="btn">Menu</button>
      <div id="pathScroller" class="pathScroller"></div>
    </div>

    <!-- Choices line (folders/pages to select) -->
    <div id="choicesLine" class="choicesLine"></div>

    <!-- Back/Forward -->
    <div class="navLine">
      <button id="backBtn" class="navBtn hidden" aria-label="Back">&lt;</button>
      <button id="fwdBtn" class="navBtn hidden" aria-label="Forward">&gt;</button>
    </div>
  </div>

  <!-- Welcome for offline setup -->
  <div id="welcome" class="welcome">
    <h3 style="margin:0 0 8px;">Offline setup</h3>
    <div class="notice">
      Choose your local <code>menu</code> folder once. Then the site will remember it and work offline.
    </div>
    <div class="welcomeActions">
      <button id="chooseMenuFolderBtn" class="choice">Choose menu folder</button>
      <button id="resetOfflineBtn" class="choice">Reset offline memory</button>
    </div>
    <div id="welcomeDebug" class="muted" style="margin-top:10px; font-size:13px;"></div>
  </div>

  <!-- Document -->
  <div class="docWrap">
    <div class="docFrame">
      <div id="docContent" class="docContent"></div>
    </div>
  </div>

<script>
/**
 * =========================================================
 *  CONFIG
 * =========================================================
 */
const ROOT = "menu";
const INDEX_FILENAME = "content-index.json";
const SEARCH_INDEX_FILENAME = "search-index.json";

/**
 * Offline persistence (Directory Handle via IndexedDB)
 */
const IDB_DB = "musical-atlas-db";
const IDB_STORE = "handles";
const IDB_KEY = "menuDirHandle";

/**
 * =========================================================
 *  DOM HELPERS
 * =========================================================
 */
const $ = (sel) => document.querySelector(sel);
const menuBtn = $("#menuBtn");
const pathScroller = $("#pathScroller");
const choicesLine = $("#choicesLine");
const docContent = $("#docContent");
const welcome = $("#welcome");
const welcomeDebug = $("#welcomeDebug");
const chooseMenuFolderBtn = $("#chooseMenuFolderBtn");
const resetOfflineBtn = $("#resetOfflineBtn");

const searchInput = $("#searchInput");
const resultsLine = $("#resultsLine");
const backBtn = $("#backBtn");
const fwdBtn = $("#fwdBtn");

/**
 * =========================================================
 *  STATE
 * =========================================================
 */
const STATE = {
  mode: "unknown",            // "github" | "offline" | "unknown"
  index: null,                // content-index.json
  handleMap: null,            // offline: path -> FileSystemFileHandle
  dirHandle: null,            // offline: menu folder handle
  menuOpen: false,
  folderPath: [],             // array of folder names under ROOT (e.g., ["ghana","coast"])
  currentDoc: null,           // { title, path } or null
  pagesByName: new Map(),     // normalizedName -> page path (unique preferred)
  foldersByName: new Map(),   // normalizedName -> folder path array (first match)
  pagePathToTitle: new Map(), // path -> title
  searchIndex: null,          // [{path,title,text}] text is normalized
};

/**
 * Navigation history tracking (Back/Forward buttons)
 */
const NAV = {
  idx: 0,
  maxIdx: 0,
  booted: false
};

/**
 * =========================================================
 *  BASIC UTILITIES
 * =========================================================
 */
function titleize(name) {
  const base = String(name).replace(/\.rtf$/i, "").replace(/[_\-]+/g, " ").trim();
  return base.replace(/\b\w/g, (c) => c.toUpperCase());
}

function normalizeName(s) {
  // exact name matching by you: we do case-insensitive, trim, remove .rtf if present
  return String(s || "").trim().replace(/\.rtf$/i, "").toLowerCase();
}

function isAllCapsToken(t) {
  return /^[A-Z]{2,}$/.test(t);
}

function clearDoc() {
  docContent.innerHTML = "";
}

/**
 * Scroll path to the end (so we always see the last crumb)
 */
function scrollPathToEnd() {
  // next frame ensures updated widths
  requestAnimationFrame(() => {
    pathScroller.scrollLeft = pathScroller.scrollWidth;
  });
}

/**
 * Show/hide choices line
 */
function showChoices(show) {
  choicesLine.style.display = show ? "flex" : "none";
}

/**
 * =========================================================
 *  INDEXEDDB (Directory Handle)
 * =========================================================
 */
function idbOpen() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_DB, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, value) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).put(value, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGet(key) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readonly");
    const req = tx.objectStore(IDB_STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbDel(key) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

/**
 * =========================================================
 *  RTF RENDERING
 * =========================================================
 */
async function renderRtfArrayBuffer(ab) {
  try { RTFJS.loggingEnabled(false); WMFJS.loggingEnabled(false); EMFJS.loggingEnabled(false); } catch {}
  const doc = new RTFJS.Document(ab);
  const htmlElements = await doc.render();
  const div = document.createElement("div");
  div.append(...htmlElements);
  return div;
}

/**
 * =========================================================
 *  BOLD DETECTION (more robust than <b>/<strong>)
 * =========================================================
 */
function elementIsBold(el) {
  if (!el || el.nodeType !== 1) return false;
  const tag = el.tagName?.toLowerCase();
  if (tag === "b" || tag === "strong") return true;

  const cs = getComputedStyle(el);
  const fw = cs.fontWeight;
  const fwNum = Number.parseInt(fw, 10);
  if (!Number.isNaN(fwNum)) return fwNum >= 600;
  return (fw || "").toLowerCase() === "bold" || (fw || "").toLowerCase() === "bolder";
}

function hasBoldAncestor(node) {
  let el = node.nodeType === 1 ? node : node.parentElement;
  while (el) {
    if (el.tagName?.toLowerCase() === "a") return false; // don't nest links
    if (elementIsBold(el)) return true;
    el = el.parentElement;
  }
  return false;
}

/**
 * =========================================================
 *  LINKING RULE (your exact intent):
 *  If token is BOLD + ALL CAPS, link to page/folder whose name matches exactly (case-insensitive),
 *  even if in another folder/subfolder.
 *
 *  Priority:
 *    1) page (rtf) exact name match
 *    2) folder exact name match
 * =========================================================
 */
function autolinkBoldCaps(container) {
  const pagesByName = STATE.pagesByName;
  const foldersByName = STATE.foldersByName;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
    acceptNode(node) {
      if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
      if (!hasBoldAncestor(node)) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });

  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  for (const tn of textNodes) {
    const text = tn.nodeValue;
    // split preserving boundaries
    const parts = text.split(/(\b)/);
    let changed = false;

    const frag = document.createDocumentFragment();

    for (const part of parts) {
      if (!part) continue;

      if (isAllCapsToken(part)) {
        const key = normalizeName(part);

        const pagePath = pagesByName.get(key);
        const folderPathArr = foldersByName.get(key);

        if (pagePath) {
          const a = document.createElement("a");
          a.href = `#page=${encodeURIComponent(pagePath)}`;
          a.textContent = part;
          frag.appendChild(a);
          changed = true;
          continue;
        }

        if (folderPathArr) {
          const a = document.createElement("a");
          a.href = `#folder=${encodeURIComponent(folderPathArr.join("/"))}`;
          a.textContent = part;
          frag.appendChild(a);
          changed = true;
          continue;
        }
      }

      frag.appendChild(document.createTextNode(part));
    }

    if (changed) tn.parentNode.replaceChild(frag, tn);
  }
}

/**
 * =========================================================
 *  INDEX BUILDERS (maps)
 * =========================================================
 */
function walkIndexFoldersAndPages() {
  STATE.pagesByName.clear();
  STATE.foldersByName.clear();
  STATE.pagePathToTitle.clear();

  function walk(node, folderPathArr) {
    // node is folder
    const folderKey = normalizeName(node.title || node.name);
    // store first match (deterministic by index order)
    if (!STATE.foldersByName.has(folderKey)) {
      // store path without ROOT prefix (because folder hash uses "ghana/sub" etc.)
      const withoutRoot = folderPathArr.slice(1);
      STATE.foldersByName.set(folderKey, withoutRoot);
    }

    for (const ch of (node.children || [])) {
      if (ch.type === "folder") {
        walk(ch, [...folderPathArr, ch.name]);
      } else if (ch.type === "page") {
        const pageKey = normalizeName(ch.title || ch.name);
        if (!STATE.pagesByName.has(pageKey)) {
          STATE.pagesByName.set(pageKey, ch.path);
        }
        STATE.pagePathToTitle.set(ch.path, ch.title || titleize(ch.name));
      }
    }
  }

  for (const top of (STATE.index?.items || [])) {
    if (top.type !== "folder") continue;
    walk(top, [ROOT, top.name]);
  }
}

function getTopFolders() {
  return (STATE.index?.items || []).filter(x => x.type === "folder");
}

function findFolderNodeByPath(pathArr) {
  // pathArr is like ["ghana","sub"] (no ROOT)
  if (!pathArr.length) return null;
  const tops = getTopFolders();
  let node = tops.find(f => f.name === pathArr[0]);
  if (!node) return null;

  for (let i = 1; i < pathArr.length; i++) {
    const next = (node.children || []).find(ch => ch.type === "folder" && ch.name === pathArr[i]);
    if (!next) return node; // stop where we can
    node = next;
  }
  return node;
}

function getCurrentFolderNode() {
  if (!STATE.folderPath.length) return null;
  return findFolderNodeByPath(STATE.folderPath);
}

function getSubfolders(node) {
  return (node?.children || []).filter(ch => ch.type === "folder");
}
function getPages(node) {
  return (node?.children || []).filter(ch => ch.type === "page");
}

/**
 * =========================================================
 *  MENU BUTTON (white->black toggle)
 * =========================================================
 */
function setMenuButtonActive(active) {
  STATE.menuOpen = active;
  menuBtn.classList.toggle("active", active);
}

/**
 * =========================================================
 *  PATH UI (black chips), NO “Menu” crumb
 *  Includes folder chips, and (when doc open) a final doc chip.
 * =========================================================
 */
function buildPathUI() {
  pathScroller.innerHTML = "";

  // folder crumbs
  for (let i = 0; i < STATE.folderPath.length; i++) {
    const sub = STATE.folderPath.slice(0, i + 1);
    const node = findFolderNodeByPath(sub);
    const label = node?.title || titleize(STATE.folderPath[i]);

    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = label;

    chip.onclick = () => {
      navToFolder(sub, {push: true, keepMenu: true, clearDocIfNoRtf: true});
    };

    pathScroller.appendChild(chip);
  }

  // doc crumb (if open)
  if (STATE.currentDoc?.title) {
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = STATE.currentDoc.title;
    // clickable: just re-open the same doc
    chip.onclick = () => {
      openPage(STATE.currentDoc.path, STATE.currentDoc.title, {push: true});
    };
    pathScroller.appendChild(chip);
  }

  scrollPathToEnd();
}

/**
 * =========================================================
 *  CHOICES LINE (white buttons)
 *  Rules:
 *   - Only visible when menu is open AND we are not “at a doc end-state”
 *   - If a doc is open, we hide OTHER RTF buttons. (Folders can still show.)
 * =========================================================
 */
function isDocEndState() {
  // If a doc is open, we consider it end-state for showing sibling RTFs.
  // Menu can still show folders (so you can go deeper), but you asked to hide other RTF files line.
  return Boolean(STATE.currentDoc);
}

function buildChoicesUI() {
  choicesLine.innerHTML = "";

  if (!STATE.menuOpen) {
    showChoices(false);
    return;
  }

  // menu open: root shows top folders
  if (!STATE.folderPath.length) {
    for (const top of getTopFolders()) {
      const b = document.createElement("div");
      b.className = "choice";
      b.textContent = top.title;
      b.onclick = () => navToFolder([top.name], {push: true, keepMenu: true, clearDocIfNoRtf: true});
      choicesLine.appendChild(b);
    }
    showChoices(true);
    return;
  }

  const node = getCurrentFolderNode();
  if (!node) {
    showChoices(false);
    return;
  }

  // Subfolders always shown (text only)
  for (const f of getSubfolders(node)) {
    const b = document.createElement("div");
    b.className = "choice";
    b.textContent = f.title;
    b.onclick = () => navToFolder([...STATE.folderPath, f.name], {push: true, keepMenu: true, clearDocIfNoRtf: true});
    choicesLine.appendChild(b);
  }

  // RTF choices:
  // - show only if > 1 AND no doc open (to avoid showing siblings once doc is open)
  const pages = getPages(node);
  if (!isDocEndState() && pages.length > 1) {
    for (const p of pages) {
      const b = document.createElement("div");
      b.className = "choice";
      b.textContent = p.title;
      b.onclick = () => openPage(p.path, p.title, {push: true});
      choicesLine.appendChild(b);
    }
  }

  // If nothing to show, still show line (empty means “no choices”), but you wanted clean:
  showChoices(Boolean(choicesLine.childElementCount));
}

/**
 * =========================================================
 *  AUTO-OPEN RULES
 *  - If folder has exactly 1 RTF (even if it also has subfolders), open it automatically.
 *  - If folder has 0 RTF, clear content.
 * =========================================================
 */
async function autoOpenOrClearForFolder(node, {push} = {push:false}) {
  const pages = getPages(node);

  if (pages.length === 1) {
    // open presentation doc automatically (but do not push history unless you want to)
    await openPage(pages[0].path, pages[0].title, {push, silentHash: false, auto: true});
    return;
  }

  // no RTF: blank content, and remove currentDoc from path
  if (pages.length === 0) {
    STATE.currentDoc = null;
    clearDoc();
    buildPathUI();
    // Also, when no RTF, choices may be visible (folders); rebuild choices
    buildChoicesUI();
  }
}

/**
 * =========================================================
 *  PAGE LOADING (GitHub fetch OR offline handle)
 * =========================================================
 */
async function openPage(path, title, {push = true, silentHash = false, auto = false} = {}) {
  STATE.currentDoc = { path, title: title || titleize(path.split("/").pop()) };

  // Update UI immediately (doc becomes part of path; choices may hide sibling RTFs)
  buildPathUI();
  buildChoicesUI();
  showChoices(STATE.menuOpen && Boolean(choicesLine.childElementCount)); // keep consistent

  // Push navigation state
  if (push) pushNavState();

  // Hash update
  if (!silentHash) {
    location.hash = `page=${encodeURIComponent(path)}`;
  }

  clearDoc();

  try {
    let ab;

    if (STATE.mode === "offline" && STATE.handleMap && STATE.handleMap[path]) {
      const fh = STATE.handleMap[path];
      const file = await fh.getFile();
      ab = await file.arrayBuffer();
    } else {
      const res = await fetch(path);
      if (!res.ok) throw new Error("Failed to fetch");
      ab = await res.arrayBuffer();
    }

    const htmlDiv = await renderRtfArrayBuffer(ab);
    autolinkBoldCaps(htmlDiv);

    docContent.innerHTML = "";
    docContent.appendChild(htmlDiv);

    // If we auto-opened, keep menu behavior as user wanted:
    // menu can remain open; path already shows doc at end.
    // (No extra action needed.)
  } catch (err) {
    docContent.innerHTML = `<div class="muted">Failed to render RTF: ${String(err.message || err)}</div>`;
  }
}

/**
 * =========================================================
 *  NAVIGATE TO FOLDER
 * =========================================================
 */
async function navToFolder(pathArr, {push = true, keepMenu = true, clearDocIfNoRtf = true} = {}) {
  STATE.folderPath = pathArr.slice();
  STATE.currentDoc = null; // switching folders resets current doc unless auto-open sets it again

  if (keepMenu) {
    // Keep menu open state unchanged
  } else {
    setMenuButtonActive(false);
  }

  buildPathUI();
  buildChoicesUI();

  if (push) pushNavState();

  // Hash update for folder
  location.hash = `folder=${encodeURIComponent(pathArr.join("/"))}`;

  const node = getCurrentFolderNode();
  if (node) await autoOpenOrClearForFolder(node, {push:false});
  if (clearDocIfNoRtf && node && getPages(node).length === 0) {
    clearDoc();
  }

  // Rebuild (auto-open may have opened a doc and changed path)
  buildPathUI();
  buildChoicesUI();
}

/**
 * =========================================================
 *  HASH HANDLING (deep links)
 * =========================================================
 */
function handleHash() {
  const h = (location.hash || "").replace(/^#/, "");
  const params = new URLSearchParams(h);

  const folder = params.get("folder");
  const page = params.get("page");

  if (folder) {
    const parts = decodeURIComponent(folder).split("/").filter(Boolean);
    if (parts.length) {
      navToFolder(parts, {push: false, keepMenu: true, clearDocIfNoRtf: true});
    }
    return;
  }

  if (page) {
    const pagePath = decodeURIComponent(page);
    const title = STATE.pagePathToTitle.get(pagePath) || titleize(pagePath.split("/").pop());
    openPage(pagePath, title, {push: false, silentHash: true});
    return;
  }
}
window.addEventListener("hashchange", handleHash);

/**
 * =========================================================
 *  MENU TOGGLE CLICK
 * =========================================================
 */
menuBtn.addEventListener("click", async () => {
  setMenuButtonActive(!STATE.menuOpen);

  // If opening menu, we begin path only when user selects something.
  // Menu button never becomes part of breadcrumbs anyway.

  buildChoicesUI();

  // Push navigation state on menu toggle
  pushNavState();
});

/**
 * =========================================================
 *  OFFLINE SCANNING (folder picker + indexing)
 * =========================================================
 */
async function scanMenuDirectory(dirHandle) {
  const handleMap = {};

  async function scanDir(handle, relParts) {
    const node = {
      type: "folder",
      name: relParts[relParts.length - 1] || handle.name,
      title: titleize(relParts[relParts.length - 1] || handle.name),
      path: [ROOT, ...relParts].join("/"),
      children: []
    };

    for await (const [name, child] of handle.entries()) {
      if (child.kind === "directory") {
        const childNode = await scanDir(child, [...relParts, name]);
        node.children.push(childNode);
      } else if (child.kind === "file" && name.toLowerCase().endsWith(".rtf")) {
        const pagePath = [ROOT, ...relParts, name].join("/");
        node.children.push({
          type: "page",
          name,
          title: titleize(name),
          path: pagePath
        });
        handleMap[pagePath] = child;
      }
    }

    node.children.sort((a,b) => (
      a.type === b.type ? a.title.localeCompare(b.title) : (a.type === "folder" ? -1 : 1)
    ));

    return node;
  }

  // Countries = subfolders inside /menu
  const items = [];
  for await (const [name, child] of dirHandle.entries()) {
    if (child.kind !== "directory") continue;
    items.push(await scanDir(child, [name]));
  }
  items.sort((a,b) => a.title.localeCompare(b.title));

  // Flat map for titles (used for deep links)
  const flatPagesByKey = {};
  function flatten(node) {
    for (const ch of (node.children || [])) {
      if (ch.type === "page") {
        const key = normalizeName(ch.title);
        if (!flatPagesByKey[key]) flatPagesByKey[key] = { title: ch.title, path: ch.path };
      } else if (ch.type === "folder") flatten(ch);
    }
  }
  for (const it of items) flatten(it);

  const index = {
    generatedAt: new Date().toISOString(),
    root: ROOT,
    items,
    flatPagesByKey
  };

  return { index, handleMap };
}

/**
 * =========================================================
 *  SEARCH (Option 1):
 *   - GitHub: fetch search-index.json
 *   - Offline: build search index by reading all RTF files (once) using handleMap
 *
 *  Search behavior:
 *   - type -> results show as horizontal buttons
 *   - clicking result opens that page
 * =========================================================
 */
function normalizeTextForSearch(s) {
  return String(s || "").toLowerCase();
}

// Very simple RTF -> plain text extraction (good enough for search)
function rtfToPlainText(rtf) {
  let s = String(rtf || "");

  // Remove RTF groups like {\*\...}
  s = s.replace(/\{\\\*[^{}]*\}/g, " ");

  // Replace escaped hex \'hh
  s = s.replace(/\\'[0-9a-fA-F]{2}/g, " ");

  // Remove control words (e.g. \par, \fs24, \b0, etc.)
  s = s.replace(/\\[a-zA-Z]+\d* ?/g, " ");

  // Remove braces
  s = s.replace(/[{}]/g, " ");

  // Collapse whitespace
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

async function ensureSearchIndexLoaded() {
  if (STATE.searchIndex) return;

  // GitHub mode: load prebuilt search-index.json
  if (STATE.mode === "github") {
    try {
      const res = await fetch("./" + SEARCH_INDEX_FILENAME, {cache:"no-store"});
      if (!res.ok) throw new Error("no search index");
      const data = await res.json();
      STATE.searchIndex = (data.items || []).map(it => ({
        path: it.path,
        title: it.title,
        text: normalizeTextForSearch(it.text || "")
      }));
      return;
    } catch {
      // fallback: no index
      STATE.searchIndex = [];
      return;
    }
  }

  // Offline: build once from handleMap
  if (STATE.mode === "offline" && STATE.handleMap) {
    const items = [];
    const entries = Object.entries(STATE.handleMap);

    for (const [path, fh] of entries) {
      try {
        const file = await fh.getFile();
        const txt = await file.text();
        const plain = rtfToPlainText(txt);
        items.push({
          path,
          title: STATE.pagePathToTitle.get(path) || titleize(path.split("/").pop()),
          text: normalizeTextForSearch(plain)
        });
      } catch {
        // ignore
      }
    }
    STATE.searchIndex = items;
    return;
  }

  STATE.searchIndex = [];
}

function renderSearchResults(results) {
  resultsLine.innerHTML = "";

  if (!results.length) {
    resultsLine.style.display = "none";
    return;
  }

  for (const r of results) {
    const b = document.createElement("div");
    b.className = "resultBtn";
    b.textContent = r.title;
    b.onclick = () => openPage(r.path, r.title, {push:true});
    resultsLine.appendChild(b);
  }

  resultsLine.style.display = "flex";
  // Keep rightmost results visible when many
  requestAnimationFrame(() => {
    resultsLine.scrollLeft = 0; // start at left
  });
}

let searchTimer = null;
searchInput.addEventListener("input", () => {
  const q = searchInput.value.trim();
  if (searchTimer) clearTimeout(searchTimer);

  searchTimer = setTimeout(async () => {
    const query = q.trim();
    if (!query) {
      resultsLine.style.display = "none";
      resultsLine.innerHTML = "";
      return;
    }

    await ensureSearchIndexLoaded();
    const nq = normalizeTextForSearch(query);

    // Simple contains search; returns top 20
    const hits = [];
    for (const it of (STATE.searchIndex || [])) {
      if (!it.text) continue;
      if (it.text.includes(nq)) hits.push(it);
      if (hits.length >= 20) break;
    }

    renderSearchResults(hits);
  }, 180);
});

/**
 * =========================================================
 *  BACK / FORWARD via History API
 * =========================================================
 */
function updateNavButtons() {
  const canBack = NAV.idx > 0;
  const canFwd = NAV.idx < NAV.maxIdx;

  backBtn.classList.toggle("hidden", !canBack);
  fwdBtn.classList.toggle("hidden", !canFwd);
}

function currentNavSnapshot() {
  return {
    menuOpen: STATE.menuOpen,
    folderPath: STATE.folderPath.slice(),
    currentDoc: STATE.currentDoc ? {...STATE.currentDoc} : null,
    // store hash target too
    hash: location.hash || ""
  };
}

function applyNavSnapshot(snap) {
  if (!snap) return;

  setMenuButtonActive(Boolean(snap.menuOpen));
  STATE.folderPath = Array.isArray(snap.folderPath) ? snap.folderPath.slice() : [];
  STATE.currentDoc = snap.currentDoc ? {...snap.currentDoc} : null;

  buildPathUI();
  buildChoicesUI();

  // If snapshot points to a doc, render it; otherwise auto-open/clear based on folder
  if (STATE.currentDoc?.path) {
    openPage(STATE.currentDoc.path, STATE.currentDoc.title, {push:false, silentHash:true});
  } else {
    const node = getCurrentFolderNode();
    if (node) autoOpenOrClearForFolder(node, {push:false});
    else clearDoc();
  }

  updateNavButtons();
}

function pushNavState() {
  if (!NAV.booted) return;

  NAV.idx += 1;
  NAV.maxIdx = NAV.idx;

  const state = { __idx: NAV.idx, snap: currentNavSnapshot() };
  history.pushState(state, "", location.hash || "#");

  updateNavButtons();
}

window.addEventListener("popstate", (ev) => {
  const st = ev.state;
  if (!st || typeof st.__idx !== "number") {
    // If unknown, just refresh buttons
    updateNavButtons();
    return;
  }
  NAV.idx = st.__idx;
  NAV.maxIdx = Math.max(NAV.maxIdx, NAV.idx); // conservative
  applyNavSnapshot(st.snap);
});

backBtn.addEventListener("click", () => history.back());
fwdBtn.addEventListener("click", () => history.forward());

/**
 * =========================================================
 *  WELCOME / OFFLINE BUTTONS
 * =========================================================
 */
chooseMenuFolderBtn.addEventListener("click", async () => {
  welcomeDebug.textContent = "";

  try {
    if (!("showDirectoryPicker" in window)) {
      throw new Error("Folder picking not supported in this browser. Use Chrome or Edge.");
    }
    const dirHandle = await window.showDirectoryPicker({ mode: "read" });

    await idbSet(IDB_KEY, dirHandle);

    const { index, handleMap } = await scanMenuDirectory(dirHandle);

    STATE.mode = "offline";
    STATE.index = index;
    STATE.dirHandle = dirHandle;
    STATE.handleMap = handleMap;

    walkIndexFoldersAndPages();
    await ensureSearchIndexLoaded(); // offline build once (quietly)

    welcome.style.display = "none";

    // Start clean: menu closed, no path selected, no doc
    setMenuButtonActive(false);
    STATE.folderPath = [];
    STATE.currentDoc = null;
    buildPathUI();
    buildChoicesUI();
    clearDoc();

    // boot history
    bootHistory();

    // Handle deep links if present
    handleHash();

  } catch (e) {
    welcomeDebug.textContent = String(e.message || e);
  }
});

resetOfflineBtn.addEventListener("click", async () => {
  await idbDel(IDB_KEY);
  STATE.mode = "unknown";
  STATE.index = null;
  STATE.dirHandle = null;
  STATE.handleMap = null;
  STATE.searchIndex = null;

  STATE.folderPath = [];
  STATE.currentDoc = null;
  setMenuButtonActive(false);

  buildPathUI();
  buildChoicesUI();
  clearDoc();

  // reset history visuals
  NAV.idx = 0;
  NAV.maxIdx = 0;
  NAV.booted = false;
  updateNavButtons();

  welcome.style.display = "block";
  welcomeDebug.textContent = "Offline memory cleared.";
});

/**
 * =========================================================
 *  BOOT (GitHub first, else Offline handle, else Welcome)
 * =========================================================
 */
async function tryLoadGithubIndex() {
  try {
    const res = await fetch("./" + INDEX_FILENAME, { cache: "no-store" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

async function tryLoadOfflineHandle() {
  try {
    const h = await idbGet(IDB_KEY);
    if (!h) return null;

    const perm = await h.requestPermission({ mode: "read" });
    if (perm !== "granted") return null;

    return h;
  } catch {
    return null;
  }
}

function bootHistory() {
  // Initialize history once per session
  NAV.idx = 0;
  NAV.maxIdx = 0;
  NAV.booted = true;

  const init = { __idx: 0, snap: currentNavSnapshot() };
  history.replaceState(init, "", location.hash || "#");

  updateNavButtons();
}

(async function boot() {
  // Attempt GitHub mode
  const ghIndex = await tryLoadGithubIndex();
  if (ghIndex) {
    STATE.mode = "github";
    STATE.index = ghIndex;

    walkIndexFoldersAndPages();

    // Load search index lazily (on first search input), but you chose Option 1:
    // We'll still load on demand to keep startup snappy.

    welcome.style.display = "none";

    // Clean start: header + search + menu button (white), no path
    setMenuButtonActive(false);
    STATE.folderPath = [];
    STATE.currentDoc = null;
    buildPathUI();
    buildChoicesUI();
    clearDoc();

    bootHistory();
    handleHash();
    return;
  }

  // Attempt offline handle
  const handle = await tryLoadOfflineHandle();
  if (handle) {
    const { index, handleMap } = await scanMenuDirectory(handle);
    STATE.mode = "offline";
    STATE.index = index;
    STATE.dirHandle = handle;
    STATE.handleMap = handleMap;

    walkIndexFoldersAndPages();
    // Build offline search index on demand (first search). If you want immediate, uncomment:
    // await ensureSearchIndexLoaded();

    welcome.style.display = "none";

    setMenuButtonActive(false);
    STATE.folderPath = [];
    STATE.currentDoc = null;
    buildPathUI();
    buildChoicesUI();
    clearDoc();

    bootHistory();
    handleHash();
    return;
  }

  // Needs offline setup
  STATE.mode = "unknown";
  STATE.index = null;

  setMenuButtonActive(false);
  STATE.folderPath = [];
  STATE.currentDoc = null;
  buildPathUI();
  buildChoicesUI();
  clearDoc();

  // No history yet, because user still hasn't “entered”
  NAV.idx = 0;
  NAV.maxIdx = 0;
  NAV.booted = false;
  updateNavButtons();

  welcome.style.display = "block";
})();
</script>
</body>
</html>
