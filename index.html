<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Musical Atlas</title>

  <style>
    :root{
      /* 75% of previous max width (900px -> 675px) */
      --col-max: 675px;
      --col: min(var(--col-max), calc(100vw - 28px));

      --ui-bg: #000;
      --ui-fg: #fff;
      --ui-border: #fff;

      --doc-bg: #fff;
      --doc-fg: #000;
      --doc-border: #000;
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      background: var(--ui-bg);
      color: var(--ui-fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .col{ width: var(--col); margin: 0 auto; }
    .wrap{ padding: 18px 0 74px; }

    #headerTitle{
      margin: 0;
      padding: 6px 0 2px;
      text-align: center;
      font-weight: 800;
      letter-spacing: 0.08em;
      cursor: pointer;
      user-select: none;
      font-size: 28px;
    }

    .searchRow{ padding: 10px 0 6px; }
    #searchInput{
      width: 100%;
      padding: 10px 12px;
      border: 2px solid var(--ui-border);
      border-radius: 12px;
      background: #000;
      color: #fff;
      font-size: 14px;
      outline: none;
    }
    #searchInput::placeholder{ color: rgba(255,255,255,0.65); }

    /* Search results row directly under the search bar */
    .resultsRow{
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 8px 0 10px;
      min-height: 36px;
    }

    .navRow{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 0 6px;
    }
    .navLeft{ display:flex; gap: 8px; flex:0 0 auto; }
    .navMid{ flex:0 0 auto; display:flex; align-items:center; gap:8px; }
    .navRight{ flex:1 1 auto; display:flex; justify-content:flex-end; min-width:0; }

    #crumbs{
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 2px;
      max-width: 100%;
      scrollbar-width: thin;
    }

    .btn{
      border: 2px solid var(--ui-border);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      background: #000;
      color: #fff;
      user-select: none;
      white-space: nowrap;
    }
    .btn.sel{
      background: #fff;
      color: #000;
      border-color: #fff;
    }
    .btn.hidden{ display:none; }

    .choicesRow{
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 0 10px;
      min-height: 36px;
    }

    .docFrame{
      border: 2px solid var(--doc-border);
      border-radius: 18px;
      padding: 16px 16px;
      background: var(--doc-bg);
      color: var(--doc-fg);
    }
    #docContent{
      line-height: 1.55;
      font-size: 15px;
      overflow-wrap: anywhere;
    }

    .welcomeMsg{
      text-align: center;
      white-space: pre-line;
      font-size: 16px;
      margin: 18px 0;
      color: var(--doc-fg);
    }

    .atlasLink{
      cursor: pointer;
      text-decoration: none !important;
      color: inherit !important;
    }

    #hoverCard{
      position: fixed;
      z-index: 9999;
      max-width: min(320px, 80vw);
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 12px;
      display: none;
      pointer-events: none;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
    }

    footer{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: #000;
      color: #fff;
      border-top: 2px solid #fff;
      padding: 8px 0;
      white-space: pre-line;
      font-size: 12px;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="col">
      <h1 id="headerTitle">MUSICAL ATLAS</h1>

      <div class="searchRow">
        <input id="searchInput" type="search" placeholder="Search..." autocomplete="off" />
      </div>

      <div id="resultsRow" class="resultsRow" aria-label="Search results"></div>

      <div class="navRow" aria-label="Navigation">
        <div class="navLeft">
          <button id="backBtn" class="btn hidden" aria-label="Back">&lt;</button>
          <button id="fwdBtn" class="btn hidden" aria-label="Forward">&gt;</button>
        </div>

        <div class="navMid">
          <button id="menuBtn" class="btn" aria-label="Menu">Menu</button>
        </div>

        <div class="navRight">
          <div id="crumbs" aria-label="Path"></div>
        </div>
      </div>

      <div id="choicesRow" class="choicesRow" aria-label="Choices"></div>

      <div class="docFrame">
        <div id="docContent"></div>
      </div>
    </div>
  </div>

  <div id="hoverCard"></div>

  <footer>
    <div class="col">Music for the People.
by Leo G.</div>
  </footer>

<script>
(() => {
  "use strict";

  const INDEX_FILENAME = "content-index.json";
  const SEARCH_INDEX_FILENAME = "search-index.json";

  const WELCOME_TEXT = `Welcome!
Click Menu to explore the Atlas
or search from the bar above.`;

  const $ = (sel) => document.querySelector(sel);

  const headerTitle = $("#headerTitle");
  const searchInput  = $("#searchInput");
  const menuBtn      = $("#menuBtn");
  const backBtn      = $("#backBtn");
  const fwdBtn       = $("#fwdBtn");
  const crumbs       = $("#crumbs");
  const choicesRow   = $("#choicesRow");
  const resultsRow   = $("#resultsRow");
  const docContent   = $("#docContent");
  const hoverCard    = $("#hoverCard");

  const APP = {
    mode: "unknown",
    index: null,
    searchIndex: [],
    rootNode: null,

    rootHandle: null,
    fileHandleByPath: new Map(),

    menuOverlay: false,
    folderPath: [],
    currentDocPath: null,

    navStack: [],
    navIdx: -1,

    pageByKey: new Map(),
    folderByKey: new Map(),

    // vendor load tracking
    vendorReady: false,
    vendorLoadTried: false
  };

  function setMenuActive(active){ menuBtn.classList.toggle("sel", !!active); }
  function hideHoverCard(){ hoverCard.style.display = "none"; hoverCard.textContent = ""; }

  const normalizeKey = (s) => String(s || "").trim().replace(/\.rtf$/i, "").toLowerCase();
  const titleize = (name) => String(name || "").replace(/\.rtf$/i,"").replace(/[_\-]+/g," ").trim().replace(/\b\w/g, c => c.toUpperCase());

  const escapeHtml = (s) =>
    String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");

  function showWelcome(){
    APP.menuOverlay = false;
    setMenuActive(false);
    APP.folderPath = [];
    APP.currentDocPath = null;

    crumbs.innerHTML = "";
    choicesRow.innerHTML = "";
    resultsRow.innerHTML = "";
    hideHoverCard();

    docContent.innerHTML = `<div class="welcomeMsg">${escapeHtml(WELCOME_TEXT)}</div>`;
    updateBackForwardButtons();
  }

  function rtfBundlesLoaded(){
    return (typeof window.RTFJS !== "undefined") &&
           (typeof window.WMFJS !== "undefined") &&
           (typeof window.EMFJS !== "undefined");
  }

  function loadScript(src){
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.async = false;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureRtfVendorLoaded(){
    if (rtfBundlesLoaded()){
      APP.vendorReady = true;
      return true;
    }
    if (APP.vendorLoadTried){
      // already tried and failed
      return false;
    }
    APP.vendorLoadTried = true;

    const base = new URL(".", location.href).href;

    const files = [
      "vendor/WMFJS.bundle.js",
      "vendor/EMFJS.bundle.js",
      "vendor/RTFJS.bundle.js"
    ];

    try{
      // Load in required order
      await loadScript("./" + files[0]);
      await loadScript("./" + files[1]);
      await loadScript("./" + files[2]);

      if (!rtfBundlesLoaded()){
        throw new Error("Scripts loaded but globals not found (WMFJS/EMFJS/RTFJS).");
      }

      APP.vendorReady = true;
      return true;
    }catch(e){
      docContent.innerHTML =
        `<div class="welcomeMsg">
RTF renderer not loaded.

Make sure this folder exists NEXT TO index.html:
<b>vendor</b>

And inside it you have EXACTLY these 3 files:
<b>WMFJS.bundle.js</b>
<b>EMFJS.bundle.js</b>
<b>RTFJS.bundle.js</b>

Quick check (open these in your browser):
${files.map(f => `<br/><b>${escapeHtml(base + f)}</b>`).join("")}
</div>`;
      return false;
    }
  }

  async function tryLoadOnlineIndexes(){
    try{
      const [idxRes, sRes] = await Promise.all([
        fetch("./" + INDEX_FILENAME, { cache: "no-store" }),
        fetch("./" + SEARCH_INDEX_FILENAME, { cache: "no-store" }),
      ]);
      if (!idxRes.ok || !sRes.ok) return false;

      const index = await idxRes.json();
      const searchIndex = await sRes.json();

      if (!index || !index.tree || index.tree.type !== "folder") return false;

      APP.mode = "online";
      APP.index = index;
      APP.searchIndex = Array.isArray(searchIndex) ? searchIndex : [];
      APP.rootNode = index.tree;

      buildLookupsFromIndex();
      return true;
    }catch{
      return false;
    }
  }

  async function rtfToPlainTextFromFile(file){
    const raw = await file.text();
    let s = String(raw || "");
    s = s.replace(/\{\\\*[^{}]*\}/g, " ");
    s = s.replace(/\\'[0-9a-fA-F]{2}/g, " ");
    s = s.replace(/\\[a-zA-Z]+\d* ?/g, " ");
    s = s.replace(/[{}]/g, " ");
    s = s.replace(/\s+/g, " ").trim();
    return s;
  }

  async function scanOfflineRoot(handle){
    APP.fileHandleByPath.clear();

    const rootName = handle.name;
    const rootNode = {
      type: "folder",
      name: rootName,
      title: titleize(rootName),
      path: rootName,
      children: []
    };

    const searchItems = [];

    async function scanFolder(folderHandle, relParts, folderNode){
      for await (const [name, entry] of folderHandle.entries()){
        if (entry.kind === "directory"){
          const childFolder = {
            type: "folder",
            name,
            title: titleize(name),
            path: [rootName, ...relParts, name].join("/"),
            children: []
          };
          folderNode.children.push(childFolder);
          await scanFolder(entry, [...relParts, name], childFolder);
        } else if (entry.kind === "file" && /\.rtf$/i.test(name)){
          const pagePath = [rootName, ...relParts, name].join("/");
          const pageNode = { type:"page", name, title: titleize(name), path: pagePath };
          folderNode.children.push(pageNode);
          APP.fileHandleByPath.set(pagePath, entry);

          try{
            const f = await entry.getFile();
            const text = await rtfToPlainTextFromFile(f);
            searchItems.push({ path: pagePath, title: pageNode.title, text });
          }catch{}
        }
      }

      folderNode.children.sort((a,b) => {
        if (a.type !== b.type) return a.type === "folder" ? -1 : 1;
        return a.title.localeCompare(b.title);
      });
    }

    await scanFolder(handle, [], rootNode);

    APP.mode = "offline";
    APP.index = { generatedAt: new Date().toISOString(), root: rootName, tree: rootNode };
    APP.rootNode = rootNode;
    APP.searchIndex = searchItems;

    buildLookupsFromIndex();
  }

  function buildLookupsFromIndex(){
    APP.pageByKey.clear();
    APP.folderByKey.clear();

    function walk(node){
      if (!node) return;
      if (node.type === "folder"){
        APP.folderByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
        for (const ch of (node.children || [])) walk(ch);
      } else if (node.type === "page"){
        APP.pageByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
      }
    }
    walk(APP.rootNode);
  }

  function findNodeByPath(path){
    if (!APP.rootNode) return null;
    const want = String(path || "");
    let found = null;

    (function walk(node){
      if (!node || found) return;
      if (node.path === want){ found = node; return; }
      for (const ch of (node.children || [])) walk(ch);
    })(APP.rootNode);

    return found;
  }

  function getFolderPathNodesFromParts(folderParts){
    if (!APP.rootNode) return [];
    const out = [];
    let cur = APP.rootNode;
    if (!folderParts.length) return out;
    if (folderParts[0] !== APP.rootNode.name) return out;

    out.push(cur);
    for (let i=1;i<folderParts.length;i++){
      const seg = folderParts[i];
      const next = (cur.children || []).find(ch => ch.type==="folder" && ch.name===seg);
      if (!next) break;
      out.push(next);
      cur = next;
    }
    return out;
  }

  function getParentFolderPartsOfDoc(docPath){
    const parts = String(docPath || "").split("/").filter(Boolean);
    if (parts.length < 2) return [];
    parts.pop();
    return parts;
  }

  function presentationDocPathForFolder(folderNode){
    if (!folderNode || folderNode.type !== "folder") return null;
    const want = (folderNode.name + ".rtf").toLowerCase();
    const pres = (folderNode.children || []).find(ch => ch.type==="page" && ch.name.toLowerCase() === want);
    return pres ? pres.path : null;
  }

  function listSubfolders(folderNode){
    return (folderNode.children || []).filter(ch => ch.type === "folder");
  }
  function listExtraPages(folderNode){
    const pres = presentationDocPathForFolder(folderNode);
    return (folderNode.children || []).filter(ch => ch.type === "page" && ch.path !== pres);
  }

  function buildCrumbs(){
    crumbs.innerHTML = "";
    if (APP.menuOverlay) return;

    // hidden-root: skip root crumb
    for (let i=1; i<APP.folderPath.length; i++){
      const folderNode = APP.folderPath[i];
      const b = document.createElement("button");
      b.className = "btn sel";
      b.textContent = folderNode.name.toUpperCase();
      b.addEventListener("click", () => openFolderByPath(folderNode.path, true));
      crumbs.appendChild(b);
    }
    crumbs.scrollLeft = crumbs.scrollWidth;
  }

  function buildChoices(){
    choicesRow.innerHTML = "";
    if (!APP.rootNode) return;

    if (APP.menuOverlay){
      const subfolders = listSubfolders(APP.rootNode);
      const extras = listExtraPages(APP.rootNode);

      for (const f of subfolders){
        const b = document.createElement("button");
        b.className = "btn";
        b.textContent = f.name.toUpperCase();
        b.addEventListener("click", () => {
          APP.menuOverlay = false;
          setMenuActive(false);
          openFolderByPath(f.path, true);
        });
        choicesRow.appendChild(b);
      }

      for (const p of extras){
        const b = document.createElement("button");
        b.className = "btn" + (APP.currentDocPath === p.path ? " sel" : "");
        b.textContent = p.title.toUpperCase();
        b.addEventListener("click", () => {
          APP.menuOverlay = false;
          setMenuActive(false);
          openDocByPath(p.path, true);
        });
        choicesRow.appendChild(b);
      }
      return;
    }

    const currentFolder = APP.folderPath[APP.folderPath.length - 1] || APP.rootNode;
    const subfolders = listSubfolders(currentFolder);
    const extras = listExtraPages(currentFolder);

    for (const f of subfolders){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = f.name.toUpperCase();
      b.addEventListener("click", () => openFolderByPath(f.path, true));
      choicesRow.appendChild(b);
    }

    for (const p of extras){
      const b = document.createElement("button");
      b.className = "btn" + (APP.currentDocPath === p.path ? " sel" : "");
      b.textContent = p.title.toUpperCase();
      b.addEventListener("click", () => openDocByPath(p.path, true));
      choicesRow.appendChild(b);
    }
  }

function normalizeRtfArrayBuffer(ab){
  let u8 = new Uint8Array(ab);
  if (u8.length < 4) return ab;

  // 1) Strip UTF-8 BOM (EF BB BF) if present
  if (u8[0] === 0xEF && u8[1] === 0xBB && u8[2] === 0xBF) {
    u8 = u8.slice(3);
  }

  // 2) UTF-16 BOM handling
  const b0 = u8[0], b1 = u8[1];
  const isLEBOM = (b0 === 0xFF && b1 === 0xFE);
  const isBEBOM = (b0 === 0xFE && b1 === 0xFF);
  if (isLEBOM || isBEBOM){
    const dec = new TextDecoder(isLEBOM ? "utf-16le" : "utf-16be");
    const s = dec.decode(u8);
    return new TextEncoder().encode(s).buffer;
  }

  // 3) UTF-16 without BOM heuristics
  const looksLE = u8[0] === 0x7B && u8[1] === 0x00 && u8[2] === 0x5C && u8[3] === 0x00; // "{\"
  const looksBE = u8[0] === 0x00 && u8[1] === 0x7B && u8[2] === 0x00 && u8[3] === 0x5C;
  if (looksLE || looksBE){
    const dec = new TextDecoder(looksLE ? "utf-16le" : "utf-16be");
    const s = dec.decode(u8);
    return new TextEncoder().encode(s).buffer;
  }

  // 4) If it still doesn't start with "{", try to find the first "{"
  // (some exporters add harmless bytes/newlines before the RTF header)
  if (u8[0] !== 0x7B) {
    const limit = Math.min(u8.length, 256);
    let idx = -1;
    for (let i = 0; i < limit; i++) {
      if (u8[i] === 0x7B) { idx = i; break; }
    }
    if (idx > 0) {
      u8 = u8.slice(idx);
    }
  }

  return u8.buffer;
}

  async function renderRtfArrayBuffer(ab){
    const ok = await ensureRtfVendorLoaded();
    if (!ok) return;

    try{
      window.RTFJS.loggingEnabled(false);
      window.WMFJS.loggingEnabled(false);
      window.EMFJS.loggingEnabled(false);
    }catch{}

    const normalized = normalizeRtfArrayBuffer(ab);

    const doc = new window.RTFJS.Document(normalized);
    const fragments = await doc.render();

    const container = document.createElement("div");
    for (const el of fragments) container.appendChild(el);
    docContent.appendChild(container);
  }

  async function fetchArrayBufferWithRootCaseFallback(docPath){
    // tries original, then root LOWER/UPPER/Title variants
    const original = String(docPath || "");
    const parts = original.split("/").filter(Boolean);
    if (parts.length === 0) throw new Error("Empty path");

    const root = parts[0];
    const variants = [];
    const lower = root.toLowerCase();
    const upper = root.toUpperCase();
    const title = root.charAt(0).toUpperCase() + root.slice(1).toLowerCase();

    const roots = Array.from(new Set([root, lower, upper, title]));

    for (const r of roots){
      const p = [r, ...parts.slice(1)].join("/");
      variants.push(p);
    }

    let lastErr = null;
    for (const p of variants){
      const url = encodeURI("./" + p);
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        return await res.arrayBuffer();
      }catch(e){
        lastErr = e;
      }
    }
    throw lastErr || new Error("Fetch failed");
  }

  async function loadDocArrayBuffer(docPath){
    if (!docPath) return null;

    if (APP.mode === "online"){
      return await fetchArrayBufferWithRootCaseFallback(docPath);
    }

    if (APP.mode === "offline"){
      const handle = APP.fileHandleByPath.get(docPath);
      if (!handle) throw new Error("Missing handle: " + docPath);
      const file = await handle.getFile();
      return await file.arrayBuffer();
    }

    throw new Error("No mode ready");
  }

  async function openAndRenderDoc(docPath){
  docContent.innerHTML = "";
  if (!docPath) return;

  try{
    const ab = await loadDocArrayBuffer(docPath);
    await renderRtfArrayBuffer(ab);
  }catch(e){
    // Helpful debug: first bytes
    let hex = "";
    try{
      const u = new Uint8Array(await loadDocArrayBuffer(docPath));
      hex = Array.from(u.slice(0, 16)).map(x => x.toString(16).padStart(2,"0")).join(" ");
    }catch{}

    docContent.innerHTML =
      `<div class="welcomeMsg">Could not open document.<br/><br/>
<b>Error:</b> ${escapeHtml(e?.message || String(e))}<br/>
<b>First bytes:</b> ${escapeHtml(hex || "(n/a)")}</div>`;
  }
}

  function snapshotNow(){
    return { folderPath: APP.folderPath.map(n => n.path), currentDocPath: APP.currentDocPath };
  }

  function pushSnapshot(){
    const snap = snapshotNow();
    if (APP.navIdx < APP.navStack.length - 1) APP.navStack = APP.navStack.slice(0, APP.navIdx + 1);
    APP.navStack.push(snap);
    APP.navIdx = APP.navStack.length - 1;
    updateBackForwardButtons();
  }

  async function restoreSnapshot(snap){
    if (!snap) return;

    const nodes = [];
    for (const p of (snap.folderPath || [])){
      const n = findNodeByPath(p);
      if (n && n.type === "folder") nodes.push(n);
    }
    APP.folderPath = nodes;
    APP.currentDocPath = snap.currentDocPath || null;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);
    updateBackForwardButtons();
  }

  function updateBackForwardButtons(){
    backBtn.classList.toggle("hidden", !(APP.navIdx > 0));
    fwdBtn.classList.toggle("hidden", !(APP.navIdx >= 0 && APP.navIdx < APP.navStack.length - 1));
  }

  async function openFolderByPath(folderPath, pushHist){
    const folderNode = findNodeByPath(folderPath);
    if (!folderNode || folderNode.type !== "folder") return;

    const parts = folderNode.path.split("/").filter(Boolean);
    APP.folderPath = getFolderPathNodesFromParts(parts);

    APP.currentDocPath = presentationDocPathForFolder(folderNode);

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  async function openDocByPath(docPath, pushHist){
    const docNode = findNodeByPath(docPath);
    if (!docNode || docNode.type !== "page") return;

    const parentParts = getParentFolderPartsOfDoc(docPath);
    APP.folderPath = getFolderPathNodesFromParts(parentParts);
    APP.currentDocPath = docPath;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  function renderSearchResults(items){
    resultsRow.innerHTML = "";
    for (const it of items){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = (it.title || "").toUpperCase();
      b.addEventListener("click", () => openDocByPath(it.path, true));
      resultsRow.appendChild(b);
    }
  }

  function doSearch(q){
    const query = String(q || "").trim().toLowerCase();
    if (!query){ resultsRow.innerHTML = ""; return; }
    if (!Array.isArray(APP.searchIndex)){ resultsRow.innerHTML = ""; return; }

    const hits = [];
    for (const it of APP.searchIndex){
      const hay = ((it.title || "") + " " + (it.text || "")).toLowerCase();
      if (hay.includes(query)) hits.push(it);
      if (hits.length >= 18) break;
    }
    renderSearchResults(hits);
  }

  async function promptPickOfflineRoot(){
    if (!window.showDirectoryPicker) return false;
    try{
      const handle = await window.showDirectoryPicker();
      APP.rootHandle = handle;
      await scanOfflineRoot(handle);
      return true;
    }catch{
      return false;
    }
  }

  async function ensureIndexesAvailable(){
    if (APP.index && APP.rootNode) return true;

    const okOnline = await tryLoadOnlineIndexes();
    if (okOnline) return true;

    // offline fallback
    if (!window.showDirectoryPicker) return false;
    return false;
  }

  async function onMenuClick(){
    let ready = await ensureIndexesAvailable();

    if (!ready){
      const ok = await promptPickOfflineRoot();
      if (!ok) return;
      ready = true;
    }

    APP.menuOverlay = !APP.menuOverlay;
    setMenuActive(APP.menuOverlay);

    if (APP.menuOverlay){
      crumbs.innerHTML = "";
      const rootPres = presentationDocPathForFolder(APP.rootNode);
      APP.currentDocPath = rootPres;
      await openAndRenderDoc(APP.currentDocPath);
      buildChoices();
      updateBackForwardButtons();
      return;
    }

    buildCrumbs();
    buildChoices();
    updateBackForwardButtons();
  }

  async function boot(){
    showWelcome();

    headerTitle.addEventListener("click", () => showWelcome());
    menuBtn.addEventListener("click", onMenuClick);

    backBtn.addEventListener("click", async () => {
      if (APP.navIdx > 0){
        APP.navIdx--;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    fwdBtn.addEventListener("click", async () => {
      if (APP.navIdx < APP.navStack.length - 1){
        APP.navIdx++;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    searchInput.addEventListener("input", () => doSearch(searchInput.value));
  }

  boot();
})();
</script>
</body>
</html>
