<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Musical Atlas</title>

  <style>
    :root { --w: 860px; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #fff;
      color: #000;
    }

    .wrap {
      max-width: var(--w);
      margin: 0 auto;
      padding: 22px 14px 64px;
    }

    /* Header */
    #headerTitle {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-align: center;
      cursor: pointer;
      user-select: none;
      margin: 0;
      font-size: 28px;
    }

    /* Search */
    .searchRow {
      display: flex;
      justify-content: center;
      margin: 10px 0 14px;
    }
    #searchInput {
      padding: 10px 12px;
      border: 2px solid #000;
      border-radius: 10px;
      font-size: 14px;
      outline: none;
      width: 320px; /* will be resized to match header */
    }

    /* Nav line */
    .navLine {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 10px 0 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: 2px solid #000;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      background: #fff;
      color: #000;
      user-select: none;
      white-space: nowrap;
    }
    .btn.black {
      background: #000;
      color: #fff;
    }
    .btn.hidden { display: none; }

    #crumbs {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      overflow-x: auto;
      max-width: min(92vw, var(--w));
      padding-bottom: 2px;
      scrollbar-width: thin;
    }

    /* Choices row + Search results row */
    .choicesRow, .resultsRow {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0 12px;
      min-height: 36px;
    }

    /* Content */
    .docFrame {
      border: 2px solid #000;
      border-radius: 18px;
      padding: 16px 16px;
      min-height: 320px;
      max-width: var(--w);
      margin: 0 auto;
    }
    #docContent {
      line-height: 1.55;
      font-size: 15px;
      overflow-wrap: anywhere;
    }

    .welcomeMsg {
      text-align: center;
      white-space: pre-line;
      font-size: 16px;
      margin: 18px 0;
    }

    /* Link styling (no underline/no color change) */
    .atlasLink {
      cursor: pointer;
      text-decoration: none !important;
      color: inherit !important;
    }

    /* Hover balloon */
    #hoverCard {
      position: fixed;
      z-index: 9999;
      max-width: min(320px, 80vw);
      background: #fff;
      border: 2px solid #000;
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 12px;
      display: none;
      pointer-events: none;
      box-shadow: 0 8px 22px rgba(0,0,0,0.12);
    }
    #hoverCard::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: -7px;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      border-top: 7px solid #fff;
    }
    #hoverCard::before {
      content: "";
      position: absolute;
      left: 50%;
      bottom: -8px;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid #000;
    }

    /* Footer */
    footer {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: #fff;
      border-top: 2px solid #000;
      padding: 8px 12px;
      text-align: center;
      font-size: 12px;
      white-space: pre-line;
    }
  </style>

  <!-- RTF.js (CDN). If you want *true offline* without internet, later you can download these files into your repo and change the src. -->
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/rtf.min.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/wmf.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/emf.js"></script>
</head>

<body>
  <div class="wrap">
    <h1 id="headerTitle">MUSICAL ATLAS</h1>

    <div class="searchRow">
      <input id="searchInput" type="search" placeholder="Search..." autocomplete="off" />
    </div>

    <div class="navLine" aria-label="Navigation">
      <button id="backBtn" class="btn hidden" aria-label="Back">&lt;</button>
      <button id="menuBtn" class="btn" aria-label="Menu">Menu</button>
      <div id="crumbs" aria-label="Path"></div>
      <button id="fwdBtn" class="btn hidden" aria-label="Forward">&gt;</button>
    </div>

    <div id="choicesRow" class="choicesRow" aria-label="Choices"></div>
    <div id="resultsRow" class="resultsRow" aria-label="Search results"></div>

    <div class="docFrame">
      <div id="docContent"></div>
    </div>
  </div>

  <div id="hoverCard"></div>

  <footer id="footerQuote">Music for the People.
by Leo G.</footer>

<script>
(() => {
  "use strict";

  /* =========================
     Config
  ========================= */
  const INDEX_FILENAME = "content-index.json";
  const SEARCH_INDEX_FILENAME = "search-index.json";
  const WELCOME_TEXT = `Welcome!
Click Menu to explore the Atlas
or search from the bar above.`;

  /* =========================
     DOM
  ========================= */
  const $ = (sel) => document.querySelector(sel);
  const headerTitle = $("#headerTitle");
  const searchInput = $("#searchInput");
  const menuBtn = $("#menuBtn");
  const backBtn = $("#backBtn");
  const fwdBtn = $("#fwdBtn");
  const crumbs = $("#crumbs");
  const choicesRow = $("#choicesRow");
  const resultsRow = $("#resultsRow");
  const docContent = $("#docContent");
  const hoverCard = $("#hoverCard");

  /* =========================
     State
  ========================= */
  const APP = {
    mode: "unknown", // "online" | "offline" | "unknown"
    index: null,     // { generatedAt, root, tree, flatPagesByKey? }
    searchIndex: null, // [{path,title,text}]
    rootNode: null,    // folder node (tree)
    // offline handle + file handles
    rootHandle: null,
    fileHandleByPath: new Map(), // path -> FileSystemFileHandle

    // navigation
    menuOverlay: false,       // root menu view
    folderPath: [],           // array of folder nodes (root..current)
    currentDocPath: null,     // actual displayed doc path (can be presentation)
    // history snapshots for UI back/forward
    navStack: [],
    navIdx: -1,

    // lookup maps for linking/search open
    pageByKey: new Map(),     // normalized title -> {title,path}
    folderByKey: new Map(),   // normalized title -> {title,path}
  };

  /* =========================
     Helpers
  ========================= */
  const normalizeKey = (s) =>
    String(s || "")
      .trim()
      .replace(/\.rtf$/i, "")
      .toLowerCase();

  const titleize = (name) => {
    const base = String(name || "").replace(/\.rtf$/i,"").replace(/[_\-]+/g," ").trim();
    return base.replace(/\b\w/g, c => c.toUpperCase());
  };

  const escapeHtml = (s) =>
    String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");

  function syncSearchWidthToHeader() {
    // Match search width to rendered header width (within safe bounds)
    const r = headerTitle.getBoundingClientRect();
    const w = Math.max(240, Math.min(r.width, 560));
    searchInput.style.width = w + "px";
  }

  function clearDoc() {
    docContent.innerHTML = "";
  }

  function showWelcome() {
    APP.menuOverlay = false;
    setMenuActive(false);
    clearDoc();
    crumbs.innerHTML = "";
    choicesRow.innerHTML = "";
    resultsRow.innerHTML = "";
    docContent.innerHTML = `<div class="welcomeMsg">${escapeHtml(WELCOME_TEXT)}</div>`;
    hideHoverCard();
    updateBackForwardButtons();
  }

  function setMenuActive(active) {
    menuBtn.classList.toggle("black", !!active);
  }

  function hideHoverCard() {
    hoverCard.style.display = "none";
    hoverCard.textContent = "";
  }

  function showHoverCard(anchorEl, text) {
    const rect = anchorEl.getBoundingClientRect();
    hoverCard.textContent = text;
    hoverCard.style.display = "block";
    // place above the word
    const pad = 10;
    const cardRect = hoverCard.getBoundingClientRect();
    let x = rect.left + rect.width / 2 - cardRect.width / 2;
    let y = rect.top - cardRect.height - 14;
    x = Math.max(pad, Math.min(x, window.innerWidth - cardRect.width - pad));
    y = Math.max(pad, y);
    hoverCard.style.left = x + "px";
    hoverCard.style.top = y + "px";
  }

  /* =========================
     Index loading
  ========================= */
  async function tryLoadOnlineIndexes() {
    try {
      const [idxRes, sRes] = await Promise.all([
        fetch("./" + INDEX_FILENAME, { cache: "no-store" }),
        fetch("./" + SEARCH_INDEX_FILENAME, { cache: "no-store" }),
      ]);
      if (!idxRes.ok || !sRes.ok) return false;

      const index = await idxRes.json();
      const searchIndex = await sRes.json();

      if (!index || !index.tree || index.tree.type !== "folder") return false;

      APP.mode = "online";
      APP.index = index;
      APP.searchIndex = Array.isArray(searchIndex) ? searchIndex : [];
      APP.rootNode = index.tree;

      buildLookupsFromIndex();
      return true;
    } catch {
      return false;
    }
  }

  /* =========================
     Offline persistence (IndexedDB)
  ========================= */
  const IDB_DB = "musical-atlas";
  const IDB_STORE = "handles";
  const IDB_KEY = "rootHandle";

  function idbOpen() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_DB, 1);
      req.onupgradeneeded = () => {
        req.result.createObjectStore(IDB_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbSet(key, value) {
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, "readwrite");
      tx.objectStore(IDB_STORE).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  async function idbGet(key) {
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, "readonly");
      const req = tx.objectStore(IDB_STORE).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  /* =========================
     Offline scanning (build same index format)
  ========================= */
  async function scanOfflineRoot(handle) {
    APP.fileHandleByPath.clear();

    const rootName = handle.name;
    const rootNode = {
      type: "folder",
      name: rootName,
      title: titleize(rootName),
      path: rootName,
      children: []
    };

    const searchItems = [];

    async function scanFolder(folderHandle, relParts, folderNode) {
      for await (const [name, entry] of folderHandle.entries()) {
        if (entry.kind === "directory") {
          const childFolder = {
            type: "folder",
            name,
            title: titleize(name),
            path: [rootName, ...relParts, name].join("/"),
            children: []
          };
          folderNode.children.push(childFolder);
          await scanFolder(entry, [...relParts, name], childFolder);
        } else if (entry.kind === "file" && /\.rtf$/i.test(name)) {
          const pagePath = [rootName, ...relParts, name].join("/");
          const pageNode = { type: "page", name, title: titleize(name), path: pagePath };
          folderNode.children.push(pageNode);
          APP.fileHandleByPath.set(pagePath, entry);

          try {
            const f = await entry.getFile();
            const text = await rtfToPlainTextFromFile(f);
            searchItems.push({ path: pagePath, title: pageNode.title, text });
          } catch {}
        }
      }

      // sort children: folders first, then pages, by title
      folderNode.children.sort((a,b) => {
        if (a.type !== b.type) return a.type === "folder" ? -1 : 1;
        return a.title.localeCompare(b.title);
      });
    }

    await scanFolder(handle, [], rootNode);

    APP.mode = "offline";
    APP.index = { generatedAt: new Date().toISOString(), root: rootName, tree: rootNode };
    APP.rootNode = rootNode;
    APP.searchIndex = searchItems;

    buildLookupsFromIndex();
  }

  async function rtfToPlainTextFromFile(file) {
    // Simple extraction: strip common RTF controls; good enough for search
    const raw = await file.text();
    let s = String(raw || "");
    s = s.replace(/\{\\\*[^{}]*\}/g, " ");
    s = s.replace(/\\'[0-9a-fA-F]{2}/g, " ");
    s = s.replace(/\\[a-zA-Z]+\d* ?/g, " ");
    s = s.replace(/[{}]/g, " ");
    s = s.replace(/\s+/g, " ").trim();
    return s;
  }

  /* =========================
     Lookups (links + open by title)
  ========================= */
  function buildLookupsFromIndex() {
    APP.pageByKey.clear();
    APP.folderByKey.clear();

    function walk(node) {
      if (!node) return;
      if (node.type === "folder") {
        APP.folderByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
        for (const ch of (node.children || [])) walk(ch);
      } else if (node.type === "page") {
        APP.pageByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
      }
    }
    walk(APP.rootNode);
  }

  function findNodeByPath(path) {
    if (!APP.rootNode) return null;
    const want = String(path || "");
    let found = null;

    function walk(node) {
      if (!node || found) return;
      if (node.path === want) { found = node; return; }
      for (const ch of (node.children || [])) walk(ch);
    }
    walk(APP.rootNode);
    return found;
  }

  function getParentFolderPathOfDoc(docPath) {
    const parts = String(docPath || "").split("/").filter(Boolean);
    if (parts.length < 2) return []; // root? not expected
    // drop last segment (file)
    parts.pop();
    // parts now: [root, ...folders]
    return parts;
  }

  function getFolderPathNodesFromParts(folderParts) {
    // folderParts like [root, A, B] -> nodes [rootNode, nodeA, nodeB]
    if (!APP.rootNode) return [];
    const out = [];
    let cur = APP.rootNode;
    if (!folderParts.length) return out;
    if (folderParts[0] !== APP.rootNode.name) return out;
    out.push(cur);

    for (let i=1; i<folderParts.length; i++) {
      const seg = folderParts[i];
      const next = (cur.children || []).find(ch => ch.type==="folder" && ch.name===seg);
      if (!next) break;
      out.push(next);
      cur = next;
    }
    return out;
  }

  function presentationDocPathForFolder(folderNode) {
    if (!folderNode || folderNode.type !== "folder") return null;
    const presName = folderNode.name + ".rtf";
    const pres = (folderNode.children || []).find(ch => ch.type==="page" && ch.name.toLowerCase() === presName.toLowerCase());
    return pres ? pres.path : null;
  }

  function listSubfolders(folderNode) {
    return (folderNode.children || []).filter(ch => ch.type === "folder");
  }

  function listPages(folderNode) {
    return (folderNode.children || []).filter(ch => ch.type === "page");
  }

  function listExtraPages(folderNode) {
    const pres = presentationDocPathForFolder(folderNode);
    return listPages(folderNode).filter(p => p.path !== pres);
  }

  /* =========================
     Rendering: crumbs + choices
  ========================= */
  function buildCrumbs() {
    crumbs.innerHTML = "";
    if (APP.menuOverlay) return;
    for (let i=0; i<APP.folderPath.length; i++) {
      const folderNode = APP.folderPath[i];
      const b = document.createElement("button");
      b.className = "btn black";
      b.textContent = folderNode.name.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openFolderByPath(folderNode.path, true);
      });
      crumbs.appendChild(b);
    }
    // scroll to end
    crumbs.scrollLeft = crumbs.scrollWidth;
  }

  function buildChoices() {
    choicesRow.innerHTML = "";

    // Root menu view: show the root folder as a white selectable button
    if (APP.menuOverlay) {
      if (!APP.rootNode) return;
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = APP.rootNode.name.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        APP.menuOverlay = false;
        setMenuActive(false);
        openFolderByPath(APP.rootNode.path, true); // this pushes history
      });
      choicesRow.appendChild(b);
      return;
    }

    const currentFolder = APP.folderPath[APP.folderPath.length - 1] || null;
    if (!currentFolder) return;

    const subfolders = listSubfolders(currentFolder);
    const extras = listExtraPages(currentFolder);

    const hasSubfolders = subfolders.length > 0;

    // Always show subfolders as white buttons
    for (const f of subfolders) {
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = f.name.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openFolderByPath(f.path, true);
      });
      choicesRow.appendChild(b);
    }

    // If there are extra (non-presentation) docs:
    // - show them in the white row (even if there are subfolders),
    // - and highlight the selected one as black.
    for (const p of extras) {
      const b = document.createElement("button");
      const isSelected = APP.currentDocPath === p.path;
      b.className = "btn" + (isSelected ? " black" : "");
      b.textContent = p.title.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openDocByPath(p.path, true);
      });
      choicesRow.appendChild(b);
    }
  }

  /* =========================
     RTF rendering + autolinks
  ========================= */
  async function renderRtfArrayBuffer(buf) {
    clearDoc();
    // RTFJS will insert HTML into a container
    const doc = new window.RTFJS.Document(buf);
    const fragments = await doc.render();
    const container = document.createElement("div");
    for (const el of fragments) container.appendChild(el);
    docContent.appendChild(container);

    autolinkBoldAllCaps(docContent);
  }

  function isAllCapsToken(token) {
    const t = String(token || "").trim();
    if (t.length < 2) return false;
    // allow A-Z, digits, some punctuation like '-' '’'
    const letters = t.replace(/[^A-Za-z]/g, "");
    if (letters.length < 2) return false;
    return letters === letters.toUpperCase();
  }

  function elementIsBold(el) {
    if (!el || el.nodeType !== 1) return false;
    const tag = el.tagName?.toLowerCase();
    if (tag === "b" || tag === "strong") return true;
    const w = getComputedStyle(el).fontWeight;
    const n = Number(w);
    if (!Number.isNaN(n)) return n >= 600;
    return w === "bold";
  }

  function hasBoldAncestor(node) {
    let cur = node.parentElement;
    while (cur) {
      if (elementIsBold(cur)) return true;
      cur = cur.parentElement;
    }
    return false;
  }

  function autolinkBoldAllCaps(rootEl) {
    hideHoverCard();

    // Strategy: for every text node inside a bold element, wrap ALL-CAPS tokens.
    const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, {
      acceptNode: (n) => {
        if (!n.nodeValue || !n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        if (!hasBoldAncestor(n) && !elementIsBold(n.parentElement)) return NodeFilter.FILTER_REJECT;
        return NodeFilter.FILTER_ACCEPT;
      }
    });

    const toProcess = [];
    while (walker.nextNode()) toProcess.push(walker.currentNode);

    for (const textNode of toProcess) {
      const text = textNode.nodeValue;
      if (!text) continue;

      const parts = text.split(/(\s+)/); // keep spaces
      let changed = false;

      const frag = document.createDocumentFragment();
      for (const part of parts) {
        if (/^\s+$/.test(part)) {
          frag.appendChild(document.createTextNode(part));
          continue;
        }

        // Strip edge punctuation for matching but keep original rendering
        const m = part.match(/^([("'“”‘’\[\{<]*)(.*?)([)",'.!?;:’”\]\}>]*)$/);
        const lead = m ? m[1] : "";
        const core = m ? m[2] : part;
        const tail = m ? m[3] : "";

        if (core && isAllCapsToken(core)) {
          const key = normalizeKey(core);
          const target = APP.pageByKey.get(key) || APP.folderByKey.get(key);
          if (target) {
            changed = true;

            if (lead) frag.appendChild(document.createTextNode(lead));

            const span = document.createElement("span");
            span.className = "atlasLink";
            span.textContent = core;
            span.dataset.targetPath = target.path;
            span.dataset.targetTitle = target.title;

            // Desktop hover
            span.addEventListener("mouseenter", () => showHoverCard(span, `go to ${target.title}`));
            span.addEventListener("mouseleave", () => hideHoverCard());

            // Click / touch behavior: first tap shows; second tap navigates
            let touchArmed = false;
            span.addEventListener("pointerdown", (ev) => {
              if (ev.pointerType === "touch") {
                ev.preventDefault();
                if (!touchArmed) {
                  touchArmed = true;
                  showHoverCard(span, `go to ${target.title}`);
                  // disarm after a moment
                  setTimeout(() => { touchArmed = false; }, 1200);
                } else {
                  touchArmed = false;
                  hideHoverCard();
                  navigateToPath(target.path, true);
                }
              }
            });

            span.addEventListener("click", (ev) => {
              // For mouse clicks: navigate immediately, and ensure balloon disappears now
              ev.preventDefault();
              hideHoverCard();
              navigateToPath(target.path, true);
            });

            frag.appendChild(span);

            if (tail) frag.appendChild(document.createTextNode(tail));
            continue;
          }
        }

        frag.appendChild(document.createTextNode(part));
      }

      if (changed) {
        textNode.parentNode.replaceChild(frag, textNode);
      }
    }
  }

  /* =========================
     Loading documents
  ========================= */
  async function loadDocArrayBuffer(docPath) {
    if (!docPath) return null;

    if (APP.mode === "online") {
      // fetch static file from GitHub Pages
      const url = encodeURI("./" + docPath);
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to fetch doc: " + docPath);
      return await res.arrayBuffer();
    }

    if (APP.mode === "offline") {
      const handle = APP.fileHandleByPath.get(docPath);
      if (!handle) throw new Error("Missing file handle: " + docPath);
      const file = await handle.getFile();
      return await file.arrayBuffer();
    }

    throw new Error("No mode/index loaded");
  }

  async function openAndRenderDoc(docPath) {
    clearDoc();
    if (!docPath) return;

    try {
      const buf = await loadDocArrayBuffer(docPath);
      await renderRtfArrayBuffer(buf);
    } catch (e) {
      clearDoc();
      docContent.innerHTML = `<div class="welcomeMsg">Could not open document.</div>`;
    }
  }

  /* =========================
     Navigation (folders/docs)
  ========================= */
  function snapshotNow() {
    return {
      folderPath: APP.folderPath.map(n => n.path),
      currentDocPath: APP.currentDocPath
    };
  }

  function pushSnapshot() {
    const snap = snapshotNow();
    // drop forward history
    if (APP.navIdx < APP.navStack.length - 1) {
      APP.navStack = APP.navStack.slice(0, APP.navIdx + 1);
    }
    APP.navStack.push(snap);
    APP.navIdx = APP.navStack.length - 1;
    updateBackForwardButtons();
  }

  async function restoreSnapshot(snap) {
    if (!snap) return;
    // folderPath stored as paths
    const nodes = [];
    for (const p of (snap.folderPath || [])) {
      const n = findNodeByPath(p);
      if (n && n.type === "folder") nodes.push(n);
    }
    APP.folderPath = nodes;
    APP.currentDocPath = snap.currentDocPath || null;
    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    resultsRow.innerHTML = "";
    await openAndRenderDoc(APP.currentDocPath);
    updateBackForwardButtons();
  }

  async function openFolderByPath(folderPath, pushHist) {
    hideHoverCard();
    const folderNode = findNodeByPath(folderPath);
    if (!folderNode || folderNode.type !== "folder") return;

    // build folder path nodes from root to this folder
    const parts = folderNode.path.split("/").filter(Boolean);
    const nodes = getFolderPathNodesFromParts(parts);
    APP.folderPath = nodes;

    // auto-open presentation doc (file name matches folder name)
    const pres = presentationDocPathForFolder(folderNode);
    APP.currentDocPath = pres;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    resultsRow.innerHTML = "";
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  async function openDocByPath(docPath, pushHist) {
    hideHoverCard();
    const docNode = findNodeByPath(docPath);
    if (!docNode || docNode.type !== "page") return;

    // set folder path to parent folder of doc
    const parentParts = getParentFolderPathOfDoc(docPath);
    APP.folderPath = getFolderPathNodesFromParts(parentParts);

    APP.currentDocPath = docPath;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    resultsRow.innerHTML = "";
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  async function navigateToPath(targetPath, pushHist) {
    const node = findNodeByPath(targetPath);
    if (!node) return;

    if (node.type === "folder") {
      await openFolderByPath(node.path, pushHist);
      return;
    }

    if (node.type === "page") {
      await openDocByPath(node.path, pushHist);
      return;
    }
  }

  function updateBackForwardButtons() {
    const canBack = APP.navIdx > 0;
    const canFwd = APP.navIdx >= 0 && APP.navIdx < APP.navStack.length - 1;
    backBtn.classList.toggle("hidden", !canBack);
    fwdBtn.classList.toggle("hidden", !canFwd);
  }

  /* =========================
     Search
  ========================= */
  function renderSearchResults(items) {
    resultsRow.innerHTML = "";
    for (const it of items) {
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = (it.title || "").toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openDocByPath(it.path, true);
        searchInput.blur();
      });
      resultsRow.appendChild(b);
    }
  }

  function doSearch(q) {
    const query = String(q || "").trim().toLowerCase();
    if (!query) { resultsRow.innerHTML = ""; return; }
    if (!Array.isArray(APP.searchIndex)) { resultsRow.innerHTML = ""; return; }

    const hits = [];
    for (const it of APP.searchIndex) {
      const hay = (it.title + " " + it.text).toLowerCase();
      if (hay.includes(query)) hits.push(it);
      if (hits.length >= 18) break;
    }
    renderSearchResults(hits);
  }

  /* =========================
     Menu button behavior
  ========================= */
  async function ensureIndexesAvailable() {
    if (APP.index && APP.rootNode) return true;

    // First try online (if hosted)
    const okOnline = await tryLoadOnlineIndexes();
    if (okOnline) return true;

    // If we're on https/http and online indexes are missing, do NOT pop folder picker.
    // (Hosted site should not ask for your computer folders.)
    const isWeb = location.protocol === "https:" || location.protocol === "http:";
    const canPick = !!window.showDirectoryPicker;

    if (isWeb && !canPick) {
      return false;
    }

    // Offline flow: try to re-use saved handle
    if (canPick) {
      try {
        const saved = await idbGet(IDB_KEY);
        if (saved) {
          // Request permission quietly
          const perm = await saved.queryPermission({ mode: "read" });
          if (perm === "granted") {
            APP.rootHandle = saved;
            await scanOfflineRoot(saved);
            return true;
          }
        }
      } catch {}
    }

    return false;
  }

  async function promptPickOfflineRoot() {
    if (!window.showDirectoryPicker) return false;
    try {
      const handle = await window.showDirectoryPicker();
      APP.rootHandle = handle;
      await idbSet(IDB_KEY, handle);
      await scanOfflineRoot(handle);
      return true;
    } catch {
      return false;
    }
  }

  async function onMenuClick() {
    hideHoverCard();

    const ready = await ensureIndexesAvailable();

    if (!ready && (location.protocol === "https:" || location.protocol === "http:")) {
      // Hosted mode but no indexes found:
      docContent.innerHTML = `<div class="welcomeMsg">Online indexes not found.<br/>Make sure GitHub Actions deploys <b>${INDEX_FILENAME}</b> and <b>${SEARCH_INDEX_FILENAME}</b> alongside <b>index.html</b>.</div>`;
      return;
    }

    if (!ready) {
      // likely offline/local server: ask to pick folder
      const ok = await promptPickOfflineRoot();
      if (!ok) return;
    }

    // Toggle overlay without pushing history (Change #2)
    APP.menuOverlay = !APP.menuOverlay;
    setMenuActive(APP.menuOverlay);

    // Hide crumbs in overlay; keep current content visible
    buildCrumbs();
    buildChoices();
    resultsRow.innerHTML = "";
  }

  /* =========================
     Boot
  ========================= */
  async function boot() {
    syncSearchWidthToHeader();
    window.addEventListener("resize", syncSearchWidthToHeader);

    showWelcome();

    // Preload online indexes if available, but don't navigate yet.
    await tryLoadOnlineIndexes();

    // Events
    headerTitle.addEventListener("click", () => {
      // Reset to true home (Welcome), and do not add to nav history (per rules)
      showWelcome();
      APP.folderPath = [];
      APP.currentDocPath = null;
      APP.menuOverlay = false;
      setMenuActive(false);
    });

    menuBtn.addEventListener("click", onMenuClick);

    backBtn.addEventListener("click", async () => {
      hideHoverCard();
      if (APP.navIdx > 0) {
        APP.navIdx--;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    fwdBtn.addEventListener("click", async () => {
      hideHoverCard();
      if (APP.navIdx < APP.navStack.length - 1) {
        APP.navIdx++;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    searchInput.addEventListener("input", () => doSearch(searchInput.value));
    searchInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape") {
        searchInput.value = "";
        resultsRow.innerHTML = "";
        hideHoverCard();
      }
    });

    // Ensure hover card never "sticks" after navigation or leaving the page
    document.addEventListener("click", () => hideHoverCard());
    document.addEventListener("scroll", () => hideHoverCard(), { passive: true });
  }

  boot();
})();
</script>
</body>
</html>
