<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Musical Atlas</title>

  <style>
    :root{
      /* 75% of previous max width (900px -> 675px) */
      --col-max: 675px;
      --col: min(var(--col-max), calc(100vw - 28px));

      --ui-bg: #000;
      --ui-fg: #fff;
      --ui-border: #fff;

      --doc-bg: #fff;
      --doc-fg: #000;
      --doc-border: #000;
    }

    *{ box-sizing: border-box; }

    body{
      margin:0;
      background: var(--ui-bg);
      color: var(--ui-fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .col{
      width: var(--col);
      margin: 0 auto;
    }

    .wrap{ padding: 18px 0 74px; }

    #headerTitle{
      margin: 0;
      padding: 6px 0 2px;
      text-align: center;
      font-weight: 800;
      letter-spacing: 0.08em;
      cursor: pointer;
      user-select: none;
      font-size: 28px;
    }

    .searchRow{ padding: 10px 0 6px; }
    #searchInput{
      width: 100%;
      padding: 10px 12px;
      border: 2px solid var(--ui-border);
      border-radius: 12px;
      background: #000;
      color: #fff;
      font-size: 14px;
      outline: none;
    }
    #searchInput::placeholder{ color: rgba(255,255,255,0.65); }

    /* Results now sit directly under search bar */
    .resultsRow{
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 8px 0 10px;
      min-height: 36px;
    }

    .navRow{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 0 6px;
    }
    .navLeft{
      display: flex;
      gap: 8px;
      flex: 0 0 auto;
    }
    .navMid{
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .navRight{
      flex: 1 1 auto;
      display: flex;
      justify-content: flex-end;
      min-width: 0;
    }

    #crumbs{
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 2px;
      max-width: 100%;
      scrollbar-width: thin;
    }

    /* Inverted UI buttons */
    .btn{
      border: 2px solid var(--ui-border);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      background: #000;
      color: #fff;
      user-select: none;
      white-space: nowrap;
    }
    .btn.sel{
      background: #fff;
      color: #000;
      border-color: #fff;
    }
    .btn.hidden{ display:none; }

    .choicesRow{
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 0 10px;
      min-height: 36px;
    }

    /* Document stays "paper-like" */
    .docFrame{
      border: 2px solid var(--doc-border);
      border-radius: 18px;
      padding: 16px 16px;
      background: var(--doc-bg);
      color: var(--doc-fg);
    }
    #docContent{
      line-height: 1.55;
      font-size: 15px;
      overflow-wrap: anywhere;
    }

    .welcomeMsg{
      text-align: center;
      white-space: pre-line;
      font-size: 16px;
      margin: 18px 0;
      color: var(--doc-fg);
    }

    .atlasLink{
      cursor: pointer;
      text-decoration: none !important;
      color: inherit !important;
    }

    /* Hover balloon (inverted UI) */
    #hoverCard{
      position: fixed;
      z-index: 9999;
      max-width: min(320px, 80vw);
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 12px;
      display: none;
      pointer-events: none;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
    }
    #hoverCard::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-7px;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:7px solid transparent;
      border-right:7px solid transparent;
      border-top:7px solid #000;
    }
    #hoverCard::before{
      content:"";
      position:absolute;
      left:50%;
      bottom:-8px;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:8px solid transparent;
      border-right:8px solid transparent;
      border-top:8px solid #fff;
    }

    footer{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: #000;
      color: #fff;
      border-top: 2px solid #fff;
      padding: 8px 0;
      white-space: pre-line;
      font-size: 12px;
      text-align: center;
    }
  </style>

  <!-- Local vendor bundles (autonomous) -->
  <script src="./vendor/WMFJS.bundle.js"></script>
  <script src="./vendor/EMFJS.bundle.js"></script>
  <script src="./vendor/RTFJS.bundle.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="col">
      <h1 id="headerTitle">MUSICAL ATLAS</h1>

      <div class="searchRow">
        <input id="searchInput" type="search" placeholder="Search..." autocomplete="off" />
      </div>

      <!-- Search results: directly under the search bar -->
      <div id="resultsRow" class="resultsRow" aria-label="Search results"></div>

      <div class="navRow" aria-label="Navigation">
        <div class="navLeft">
          <button id="backBtn" class="btn hidden" aria-label="Back">&lt;</button>
          <button id="fwdBtn" class="btn hidden" aria-label="Forward">&gt;</button>
        </div>

        <div class="navMid">
          <button id="menuBtn" class="btn" aria-label="Menu">Menu</button>
        </div>

        <div class="navRight">
          <div id="crumbs" aria-label="Path"></div>
        </div>
      </div>

      <div id="choicesRow" class="choicesRow" aria-label="Choices"></div>

      <div class="docFrame">
        <div id="docContent"></div>
      </div>
    </div>
  </div>

  <div id="hoverCard"></div>

  <footer>
    <div class="col">Music for the People.
by Leo G.</div>
  </footer>

<script>
(() => {
  "use strict";

  const INDEX_FILENAME = "content-index.json";
  const SEARCH_INDEX_FILENAME = "search-index.json";

  const WELCOME_TEXT = `Welcome!
Click Menu to explore the Atlas
or search from the bar above.`;

  const $ = (sel) => document.querySelector(sel);

  const headerTitle = $("#headerTitle");
  const searchInput  = $("#searchInput");
  const menuBtn      = $("#menuBtn");
  const backBtn      = $("#backBtn");
  const fwdBtn       = $("#fwdBtn");
  const crumbs       = $("#crumbs");
  const choicesRow   = $("#choicesRow");
  const resultsRow   = $("#resultsRow");
  const docContent   = $("#docContent");
  const hoverCard    = $("#hoverCard");

  const APP = {
    mode: "unknown",      // "online" | "offline" | "unknown"
    index: null,
    searchIndex: [],
    rootNode: null,

    // offline handles
    rootHandle: null,
    fileHandleByPath: new Map(), // path -> FileSystemFileHandle

    // navigation (2-line)
    menuOverlay: false,       // root menu view
    folderPath: [],           // nodes root..current
    currentDocPath: null,     // displayed doc path

    // history snapshots
    navStack: [],
    navIdx: -1,

    // link lookups
    pageByKey: new Map(),
    folderByKey: new Map(),
  };

  function setMenuActive(active){ menuBtn.classList.toggle("sel", !!active); }

  function hideHoverCard(){
    hoverCard.style.display = "none";
    hoverCard.textContent = "";
  }

  function showHoverCard(anchorEl, text){
    const rect = anchorEl.getBoundingClientRect();
    hoverCard.textContent = text;
    hoverCard.style.display = "block";

    const pad = 10;
    const cardRect = hoverCard.getBoundingClientRect();
    let x = rect.left + rect.width / 2 - cardRect.width / 2;
    let y = rect.top - cardRect.height - 14;
    x = Math.max(pad, Math.min(x, window.innerWidth - cardRect.width - pad));
    y = Math.max(pad, y);
    hoverCard.style.left = x + "px";
    hoverCard.style.top = y + "px";
  }

  const normalizeKey = (s) =>
    String(s || "").trim().replace(/\.rtf$/i, "").toLowerCase();

  const titleize = (name) => {
    const base = String(name || "").replace(/\.rtf$/i,"").replace(/[_\-]+/g," ").trim();
    return base.replace(/\b\w/g, c => c.toUpperCase());
  };

  const escapeHtml = (s) =>
    String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");

  function showWelcome(){
    APP.menuOverlay = false;
    setMenuActive(false);
    APP.folderPath = [];
    APP.currentDocPath = null;

    crumbs.innerHTML = "";
    choicesRow.innerHTML = "";
    resultsRow.innerHTML = "";
    hideHoverCard();

    docContent.innerHTML = `<div class="welcomeMsg">${escapeHtml(WELCOME_TEXT)}</div>`;
    updateBackForwardButtons();
  }

  async function tryLoadOnlineIndexes(){
    try{
      const [idxRes, sRes] = await Promise.all([
        fetch("./" + INDEX_FILENAME, { cache: "no-store" }),
        fetch("./" + SEARCH_INDEX_FILENAME, { cache: "no-store" }),
      ]);
      if (!idxRes.ok || !sRes.ok) return false;

      const index = await idxRes.json();
      const searchIndex = await sRes.json();

      if (!index || !index.tree || index.tree.type !== "folder") return false;

      APP.mode = "online";
      APP.index = index;
      APP.searchIndex = Array.isArray(searchIndex) ? searchIndex : [];
      APP.rootNode = index.tree;

      buildLookupsFromIndex();
      return true;
    }catch{
      return false;
    }
  }

  /* IndexedDB (offline handle) */
  const IDB_DB = "musical-atlas";
  const IDB_STORE = "handles";
  const IDB_KEY = "rootHandle";

  function idbOpen(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_DB, 1);
      req.onupgradeneeded = () => req.result.createObjectStore(IDB_STORE);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbSet(key, value){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, "readwrite");
      tx.objectStore(IDB_STORE).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, "readonly");
      const req = tx.objectStore(IDB_STORE).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function rtfToPlainTextFromFile(file){
    const raw = await file.text();
    let s = String(raw || "");
    s = s.replace(/\{\\\*[^{}]*\}/g, " ");
    s = s.replace(/\\'[0-9a-fA-F]{2}/g, " ");
    s = s.replace(/\\[a-zA-Z]+\d* ?/g, " ");
    s = s.replace(/[{}]/g, " ");
    s = s.replace(/\s+/g, " ").trim();
    return s;
  }

  async function scanOfflineRoot(handle){
    APP.fileHandleByPath.clear();

    const rootName = handle.name;
    const rootNode = {
      type: "folder",
      name: rootName,
      title: titleize(rootName),
      path: rootName,
      children: []
    };

    const searchItems = [];

    async function scanFolder(folderHandle, relParts, folderNode){
      for await (const [name, entry] of folderHandle.entries()){
        if (entry.kind === "directory"){
          const childFolder = {
            type: "folder",
            name,
            title: titleize(name),
            path: [rootName, ...relParts, name].join("/"),
            children: []
          };
          folderNode.children.push(childFolder);
          await scanFolder(entry, [...relParts, name], childFolder);
        } else if (entry.kind === "file" && /\.rtf$/i.test(name)){
          const pagePath = [rootName, ...relParts, name].join("/");
          const pageNode = { type:"page", name, title: titleize(name), path: pagePath };
          folderNode.children.push(pageNode);
          APP.fileHandleByPath.set(pagePath, entry);

          try{
            const f = await entry.getFile();
            const text = await rtfToPlainTextFromFile(f);
            searchItems.push({ path: pagePath, title: pageNode.title, text });
          }catch{}
        }
      }

      folderNode.children.sort((a,b) => {
        if (a.type !== b.type) return a.type === "folder" ? -1 : 1;
        return a.title.localeCompare(b.title);
      });
    }

    await scanFolder(handle, [], rootNode);

    APP.mode = "offline";
    APP.index = { generatedAt: new Date().toISOString(), root: rootName, tree: rootNode };
    APP.rootNode = rootNode;
    APP.searchIndex = searchItems;

    buildLookupsFromIndex();
  }

  function buildLookupsFromIndex(){
    APP.pageByKey.clear();
    APP.folderByKey.clear();

    function walk(node){
      if (!node) return;
      if (node.type === "folder"){
        APP.folderByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
        for (const ch of (node.children || [])) walk(ch);
      } else if (node.type === "page"){
        APP.pageByKey.set(normalizeKey(node.title), { title: node.title, path: node.path });
      }
    }
    walk(APP.rootNode);
  }

  function findNodeByPath(path){
    if (!APP.rootNode) return null;
    const want = String(path || "");
    let found = null;

    (function walk(node){
      if (!node || found) return;
      if (node.path === want){ found = node; return; }
      for (const ch of (node.children || [])) walk(ch);
    })(APP.rootNode);

    return found;
  }

  function getFolderPathNodesFromParts(folderParts){
    if (!APP.rootNode) return [];
    const out = [];
    let cur = APP.rootNode;
    if (!folderParts.length) return out;
    if (folderParts[0] !== APP.rootNode.name) return out;

    out.push(cur);
    for (let i=1;i<folderParts.length;i++){
      const seg = folderParts[i];
      const next = (cur.children || []).find(ch => ch.type==="folder" && ch.name===seg);
      if (!next) break;
      out.push(next);
      cur = next;
    }
    return out;
  }

  function getParentFolderPartsOfDoc(docPath){
    const parts = String(docPath || "").split("/").filter(Boolean);
    if (parts.length < 2) return [];
    parts.pop();
    return parts;
  }

  function presentationDocPathForFolder(folderNode){
    if (!folderNode || folderNode.type !== "folder") return null;
    const want = (folderNode.name + ".rtf").toLowerCase();
    const pres = (folderNode.children || []).find(ch => ch.type==="page" && ch.name.toLowerCase() === want);
    return pres ? pres.path : null;
  }

  function listSubfolders(folderNode){
    return (folderNode.children || []).filter(ch => ch.type === "folder");
  }

  function listExtraPages(folderNode){
    const pres = presentationDocPathForFolder(folderNode);
    return (folderNode.children || []).filter(ch => ch.type === "page" && ch.path !== pres);
  }

  function buildCrumbs(){
    crumbs.innerHTML = "";
    if (APP.menuOverlay) return;

    // hidden-root: skip root crumb
    for (let i=1; i<APP.folderPath.length; i++){
      const folderNode = APP.folderPath[i];
      const b = document.createElement("button");
      b.className = "btn sel";
      b.textContent = folderNode.name.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openFolderByPath(folderNode.path, true);
      });
      crumbs.appendChild(b);
    }
    crumbs.scrollLeft = crumbs.scrollWidth;
  }

  function buildChoices(){
    choicesRow.innerHTML = "";
    if (!APP.rootNode) return;

    if (APP.menuOverlay){
      const subfolders = listSubfolders(APP.rootNode);
      const extras = listExtraPages(APP.rootNode);

      for (const f of subfolders){
        const b = document.createElement("button");
        b.className = "btn";
        b.textContent = f.name.toUpperCase();
        b.addEventListener("click", () => {
          hideHoverCard();
          APP.menuOverlay = false;
          setMenuActive(false);
          openFolderByPath(f.path, true);
        });
        choicesRow.appendChild(b);
      }

      for (const p of extras){
        const b = document.createElement("button");
        b.className = "btn" + (APP.currentDocPath === p.path ? " sel" : "");
        b.textContent = p.title.toUpperCase();
        b.addEventListener("click", () => {
          hideHoverCard();
          APP.menuOverlay = false;
          setMenuActive(false);
          openDocByPath(p.path, true);
        });
        choicesRow.appendChild(b);
      }
      return;
    }

    const currentFolder = APP.folderPath[APP.folderPath.length - 1] || APP.rootNode;

    const subfolders = listSubfolders(currentFolder);
    const extras = listExtraPages(currentFolder);

    for (const f of subfolders){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = f.name.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openFolderByPath(f.path, true);
      });
      choicesRow.appendChild(b);
    }

    for (const p of extras){
      const b = document.createElement("button");
      b.className = "btn" + (APP.currentDocPath === p.path ? " sel" : "");
      b.textContent = p.title.toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openDocByPath(p.path, true);
      });
      choicesRow.appendChild(b);
    }
  }

  /* RTF rendering fixes */

  function rtfBundlesLoaded(){
    return (typeof window.RTFJS !== "undefined") &&
           (typeof window.WMFJS !== "undefined") &&
           (typeof window.EMFJS !== "undefined");
  }

  function normalizeRtfArrayBuffer(ab){
    const u8 = new Uint8Array(ab);
    if (u8.length < 4) return ab;

    // UTF-16 BOM
    const b0 = u8[0], b1 = u8[1];
    const isLEBOM = (b0 === 0xFF && b1 === 0xFE);
    const isBEBOM = (b0 === 0xFE && b1 === 0xFF);
    if (isLEBOM || isBEBOM){
      const dec = new TextDecoder(isLEBOM ? "utf-16le" : "utf-16be");
      const s = dec.decode(u8);
      return new TextEncoder().encode(s).buffer;
    }

    // Heuristic: UTF-16LE WITHOUT BOM (common): "{\rtf" appears as 7B 00 5C 00 72 00...
    const looksLE =
      u8[0] === 0x7B && u8[1] === 0x00 &&
      u8[2] === 0x5C && u8[3] === 0x00;

    // Heuristic: UTF-16BE WITHOUT BOM: 00 7B 00 5C 00 72...
    const looksBE =
      u8[0] === 0x00 && u8[1] === 0x7B &&
      u8[2] === 0x00 && u8[3] === 0x5C;

    if (looksLE || looksBE){
      const dec = new TextDecoder(looksLE ? "utf-16le" : "utf-16be");
      const s = dec.decode(u8);
      return new TextEncoder().encode(s).buffer;
    }

    return ab;
  }

  function isAllCapsToken(token){
    const t = String(token || "").trim();
    if (t.length < 2) return false;
    const letters = t.replace(/[^A-Za-z]/g,"");
    if (letters.length < 2) return false;
    return letters === letters.toUpperCase();
  }

  function elementIsBold(el){
    if (!el || el.nodeType !== 1) return false;
    const tag = el.tagName?.toLowerCase();
    if (tag === "b" || tag === "strong") return true;
    const w = getComputedStyle(el).fontWeight;
    const n = Number(w);
    if (!Number.isNaN(n)) return n >= 600;
    return w === "bold";
  }

  function hasBoldAncestor(node){
    let cur = node.parentElement;
    while (cur){
      if (elementIsBold(cur)) return true;
      cur = cur.parentElement;
    }
    return false;
  }

  function autolinkBoldAllCaps(rootEl){
    hideHoverCard();

    const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, {
      acceptNode: (n) => {
        if (!n.nodeValue || !n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        if (!hasBoldAncestor(n) && !elementIsBold(n.parentElement)) return NodeFilter.FILTER_REJECT;
        return NodeFilter.FILTER_ACCEPT;
      }
    });

    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);

    for (const textNode of nodes){
      const text = textNode.nodeValue;
      if (!text) continue;

      const parts = text.split(/(\s+)/);
      let changed = false;

      const frag = document.createDocumentFragment();
      for (const part of parts){
        if (/^\s+$/.test(part)){
          frag.appendChild(document.createTextNode(part));
          continue;
        }

        const m = part.match(/^([("'“”‘’\[\{<]*)(.*?)([)",'.!?;:’”\]\}>]*)$/);
        const lead = m ? m[1] : "";
        const core = m ? m[2] : part;
        const tail = m ? m[3] : "";

        if (core && isAllCapsToken(core)){
          const key = normalizeKey(core);
          const target = APP.pageByKey.get(key) || APP.folderByKey.get(key);
          if (target){
            changed = true;
            if (lead) frag.appendChild(document.createTextNode(lead));

            const span = document.createElement("span");
            span.className = "atlasLink";
            span.textContent = core;

            span.addEventListener("mouseenter", () => showHoverCard(span, `go to ${target.title}`));
            span.addEventListener("mouseleave", () => hideHoverCard());

            let touchArmed = false;
            span.addEventListener("pointerdown", (ev) => {
              if (ev.pointerType === "touch"){
                ev.preventDefault();
                if (!touchArmed){
                  touchArmed = true;
                  showHoverCard(span, `go to ${target.title}`);
                  setTimeout(() => { touchArmed = false; }, 1200);
                } else {
                  touchArmed = false;
                  hideHoverCard();
                  navigateToPath(target.path, true);
                }
              }
            });

            span.addEventListener("click", (ev) => {
              ev.preventDefault();
              hideHoverCard();
              navigateToPath(target.path, true);
            });

            frag.appendChild(span);
            if (tail) frag.appendChild(document.createTextNode(tail));
            continue;
          }
        }

        frag.appendChild(document.createTextNode(part));
      }

      if (changed){
        textNode.parentNode.replaceChild(frag, textNode);
      }
    }
  }

  async function renderRtfArrayBuffer(ab){
    if (!rtfBundlesLoaded()){
      docContent.innerHTML =
        `<div class="welcomeMsg">RTF renderer not loaded.<br/>
Make sure these files exist next to index.html:<br/>
<b>vendor/WMFJS.bundle.js</b><br/>
<b>vendor/EMFJS.bundle.js</b><br/>
<b>vendor/RTFJS.bundle.js</b></div>`;
      return;
    }

    try{
      window.RTFJS.loggingEnabled(false);
      window.WMFJS.loggingEnabled(false);
      window.EMFJS.loggingEnabled(false);
    }catch{}

    const normalized = normalizeRtfArrayBuffer(ab);

    const doc = new window.RTFJS.Document(normalized);
    const fragments = await doc.render();

    const container = document.createElement("div");
    for (const el of fragments) container.appendChild(el);
    docContent.appendChild(container);

    autolinkBoldAllCaps(docContent);
  }

  async function loadDocArrayBuffer(docPath){
    if (!docPath) return null;

    if (APP.mode === "online"){
      const url = encodeURI("./" + docPath);
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Fetch failed: " + docPath);
      return await res.arrayBuffer();
    }

    if (APP.mode === "offline"){
      const handle = APP.fileHandleByPath.get(docPath);
      if (!handle) throw new Error("Missing handle: " + docPath);
      const file = await handle.getFile();
      return await file.arrayBuffer();
    }

    throw new Error("No mode ready");
  }

  async function openAndRenderDoc(docPath){
    docContent.innerHTML = "";
    if (!docPath) return;

    try{
      const ab = await loadDocArrayBuffer(docPath);
      await renderRtfArrayBuffer(ab);
    }catch{
      docContent.innerHTML = `<div class="welcomeMsg">Could not open document.</div>`;
    }
  }

  function snapshotNow(){
    return {
      folderPath: APP.folderPath.map(n => n.path),
      currentDocPath: APP.currentDocPath
    };
  }

  function pushSnapshot(){
    const snap = snapshotNow();
    if (APP.navIdx < APP.navStack.length - 1){
      APP.navStack = APP.navStack.slice(0, APP.navIdx + 1);
    }
    APP.navStack.push(snap);
    APP.navIdx = APP.navStack.length - 1;
    updateBackForwardButtons();
  }

  async function restoreSnapshot(snap){
    if (!snap) return;

    const nodes = [];
    for (const p of (snap.folderPath || [])){
      const n = findNodeByPath(p);
      if (n && n.type === "folder") nodes.push(n);
    }
    APP.folderPath = nodes;
    APP.currentDocPath = snap.currentDocPath || null;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);

    updateBackForwardButtons();
  }

  function updateBackForwardButtons(){
    const canBack = APP.navIdx > 0;
    const canFwd  = APP.navIdx >= 0 && APP.navIdx < APP.navStack.length - 1;
    backBtn.classList.toggle("hidden", !canBack);
    fwdBtn.classList.toggle("hidden", !canFwd);
  }

  async function openFolderByPath(folderPath, pushHist){
    hideHoverCard();
    const folderNode = findNodeByPath(folderPath);
    if (!folderNode || folderNode.type !== "folder") return;

    const parts = folderNode.path.split("/").filter(Boolean);
    APP.folderPath = getFolderPathNodesFromParts(parts);

    APP.currentDocPath = presentationDocPathForFolder(folderNode);

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  async function openDocByPath(docPath, pushHist){
    hideHoverCard();
    const docNode = findNodeByPath(docPath);
    if (!docNode || docNode.type !== "page") return;

    const parentParts = getParentFolderPartsOfDoc(docPath);
    APP.folderPath = getFolderPathNodesFromParts(parentParts);
    APP.currentDocPath = docPath;

    APP.menuOverlay = false;
    setMenuActive(false);

    buildCrumbs();
    buildChoices();
    await openAndRenderDoc(APP.currentDocPath);

    if (pushHist) pushSnapshot();
  }

  async function navigateToPath(targetPath, pushHist){
    const node = findNodeByPath(targetPath);
    if (!node) return;
    if (node.type === "folder") return openFolderByPath(node.path, pushHist);
    if (node.type === "page")   return openDocByPath(node.path, pushHist);
  }

  function renderSearchResults(items){
    resultsRow.innerHTML = "";
    for (const it of items){
      const b = document.createElement("button");
      b.className = "btn";
      b.textContent = (it.title || "").toUpperCase();
      b.addEventListener("click", () => {
        hideHoverCard();
        openDocByPath(it.path, true);
        searchInput.blur();
      });
      resultsRow.appendChild(b);
    }
  }

  function doSearch(q){
    const query = String(q || "").trim().toLowerCase();
    if (!query){ resultsRow.innerHTML = ""; return; }
    if (!Array.isArray(APP.searchIndex)){ resultsRow.innerHTML = ""; return; }

    const hits = [];
    for (const it of APP.searchIndex){
      const hay = ((it.title || "") + " " + (it.text || "")).toLowerCase();
      if (hay.includes(query)) hits.push(it);
      if (hits.length >= 18) break;
    }
    renderSearchResults(hits);
  }

  async function ensureIndexesAvailable(){
    if (APP.index && APP.rootNode) return true;

    const okOnline = await tryLoadOnlineIndexes();
    if (okOnline) return true;

    const isWeb = location.protocol === "https:" || location.protocol === "http:";
    const canPick = !!window.showDirectoryPicker;

    if (isWeb && !canPick) return false;

    if (canPick){
      try{
        const saved = await idbGet(IDB_KEY);
        if (saved){
          const perm = await saved.queryPermission({ mode: "read" });
          if (perm === "granted"){
            APP.rootHandle = saved;
            await scanOfflineRoot(saved);
            return true;
          }
        }
      }catch{}
    }

    return false;
  }

  async function promptPickOfflineRoot(){
    if (!window.showDirectoryPicker) return false;
    try{
      const handle = await window.showDirectoryPicker();
      APP.rootHandle = handle;
      await idbSet(IDB_KEY, handle);
      await scanOfflineRoot(handle);
      return true;
    }catch{
      return false;
    }
  }

  async function onMenuClick(){
    hideHoverCard();

    let ready = await ensureIndexesAvailable();

    if (!ready && (location.protocol === "https:" || location.protocol === "http:")){
      docContent.innerHTML =
        `<div class="welcomeMsg">Online indexes not found.<br/>Make sure GitHub Actions deploys <b>${INDEX_FILENAME}</b> and <b>${SEARCH_INDEX_FILENAME}</b> next to <b>index.html</b>.</div>`;
      return;
    }

    if (!ready){
      const ok = await promptPickOfflineRoot();
      if (!ok) return;
      ready = true;
    }

    APP.menuOverlay = !APP.menuOverlay;
    setMenuActive(APP.menuOverlay);

    if (APP.menuOverlay){
      crumbs.innerHTML = "";

      const rootPres = presentationDocPathForFolder(APP.rootNode);
      APP.currentDocPath = rootPres;
      await openAndRenderDoc(APP.currentDocPath);

      buildChoices();
      updateBackForwardButtons();
      return;
    }

    buildCrumbs();
    buildChoices();
    updateBackForwardButtons();
  }

  async function boot(){
    showWelcome();
    await tryLoadOnlineIndexes();

    headerTitle.addEventListener("click", () => {
      hideHoverCard();
      showWelcome();
    });

    menuBtn.addEventListener("click", onMenuClick);

    backBtn.addEventListener("click", async () => {
      hideHoverCard();
      if (APP.navIdx > 0){
        APP.navIdx--;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    fwdBtn.addEventListener("click", async () => {
      hideHoverCard();
      if (APP.navIdx < APP.navStack.length - 1){
        APP.navIdx++;
        await restoreSnapshot(APP.navStack[APP.navIdx]);
      }
    });

    searchInput.addEventListener("input", () => doSearch(searchInput.value));
    searchInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape"){
        searchInput.value = "";
        resultsRow.innerHTML = "";
        hideHoverCard();
      }
    });

    document.addEventListener("click", () => hideHoverCard());
    document.addEventListener("scroll", () => hideHoverCard(), { passive: true });
  }

  boot();
})();
</script>
</body>
</html>
