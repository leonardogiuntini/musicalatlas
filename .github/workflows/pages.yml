name: Build indexes and deploy Musical Atlas to GitHub Pages

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Generate content-index.json and search-index.json
        run: |
          node - <<'NODE'
          const fs = require("fs");
          const path = require("path");

          const INDEX_OUT = "content-index.json";
          const SEARCH_OUT = "search-index.json";

          function readConfigRoot() {
            const cfgPath = "atlas-config.json";
            if (!fs.existsSync(cfgPath)) return null;
            try {
              const cfg = JSON.parse(fs.readFileSync(cfgPath, "utf8"));
              if (cfg && typeof cfg.rootFolder === "string" && cfg.rootFolder.trim()) {
                const p = cfg.rootFolder.trim();
                if (fs.existsSync(p) && fs.statSync(p).isDirectory()) return p;
              }
            } catch {}
            return null;
          }

          function titleize(name) {
            const base = String(name || "")
              .replace(/\.rtf$/i, "")
              .replace(/[_\-]+/g, " ")
              .trim();
            return base.replace(/\b\w/g, c => c.toUpperCase());
          }

          function rtfToPlainText(rtf) {
            let s = String(rtf || "");
            s = s.replace(/\{\\\*[^{}]*\}/g, " ");
            s = s.replace(/\\'[0-9a-fA-F]{2}/g, " ");
            s = s.replace(/\\[a-zA-Z]+\d* ?/g, " ");
            s = s.replace(/[{}]/g, " ");
            s = s.replace(/\s+/g, " ").trim();
            return s;
          }

          function containsRtfSomewhere(dirAbs) {
            const entries = fs.readdirSync(dirAbs, { withFileTypes: true });
            for (const ent of entries) {
              const abs = path.join(dirAbs, ent.name);
              if (ent.isFile() && /\.rtf$/i.test(ent.name)) return true;
              if (ent.isDirectory()) {
                if (ent.name === ".git" || ent.name === ".github" || ent.name === "node_modules") continue;
                if (containsRtfSomewhere(abs)) return true;
              }
            }
            return false;
          }

          function autoDetectRoot() {
            const top = fs.readdirSync(".", { withFileTypes: true })
              .filter(e => e.isDirectory())
              .map(e => e.name)
              .filter(n => n !== ".git" && n !== ".github" && n !== "node_modules")
              .sort((a,b) => a.localeCompare(b));

            for (const d of top) {
              const abs = path.join(".", d);
              if (containsRtfSomewhere(abs)) return d;
            }
            return null;
          }

          const ROOT = readConfigRoot() || autoDetectRoot();
          if (!ROOT || !fs.existsSync(ROOT) || !fs.statSync(ROOT).isDirectory()) {
            console.error("❌ No root content folder found.");
            console.error("Create a top-level folder containing .rtf files, OR add atlas-config.json like:");
            console.error('{ "rootFolder": "YOUR_FOLDER_NAME" }');
            process.exit(1);
          }

          function scanFolder(absDir, relParts, searchItems) {
            const nodeName = relParts.length ? relParts[relParts.length - 1] : ROOT;
            const nodePath = relParts.length ? [ROOT, ...relParts].join("/") : ROOT;

            const node = {
              type: "folder",
              name: nodeName,
              title: titleize(nodeName),
              path: nodePath,
              children: []
            };

            const entries = fs.readdirSync(absDir, { withFileTypes: true });
            for (const ent of entries) {
              const abs = path.join(absDir, ent.name);

              if (ent.isDirectory()) {
                node.children.push(scanFolder(abs, [...relParts, ent.name], searchItems));
                continue;
              }

              if (ent.isFile() && /\.rtf$/i.test(ent.name)) {
                const pagePath = relParts.length
                  ? [ROOT, ...relParts, ent.name].join("/")
                  : [ROOT, ent.name].join("/");

                const title = titleize(ent.name);
                node.children.push({ type: "page", name: ent.name, title, path: pagePath });

                try {
                  const raw = fs.readFileSync(abs, "utf8");
                  const text = rtfToPlainText(raw);
                  searchItems.push({ path: pagePath, title, text });
                } catch {}
              }
            }

            node.children.sort((a,b) => {
              if (a.type !== b.type) return a.type === "folder" ? -1 : 1;
              return a.title.localeCompare(b.title);
            });

            return node;
          }

          const searchItems = [];
          const tree = scanFolder(ROOT, [], searchItems);

          const contentIndex = {
            generatedAt: new Date().toISOString(),
            root: ROOT,
            tree
          };

          fs.writeFileSync(INDEX_OUT, JSON.stringify(contentIndex, null, 2));
          fs.writeFileSync(SEARCH_OUT, JSON.stringify(searchItems, null, 2));

          console.log("✅ Generated:", INDEX_OUT, "and", SEARCH_OUT);
          console.log("✅ Root folder:", ROOT);
          NODE

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: .

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
    steps:
      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4
